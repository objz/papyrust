This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
shaders/
  plasma.frag
  rainbow.frag
src/
  bin/
    daemon/
      media/
        image.rs
        mod.rs
        shader.rs
        video.rs
      wayland/
        audio/
          fifo.rs
          mod.rs
        monitors/
          manager.rs
          mod.rs
        protocol/
          events.rs
          mod.rs
          state.rs
        rendering/
          mod.rs
          renderer.rs
          surface.rs
        mod.rs
        traits.rs
        types.rs
      ipc.rs
      main.rs
      utils.rs
    cli.rs
  ui/
    components/
      lib_popup.rs
      mod.rs
      panel.rs
    loader/
      mod.rs
      project.rs
    pages/
      discover.rs
      library.rs
      mod.rs
    ipc.rs
    mod.rs
    state.rs
    view.rs
  main.rs
.gitignore
build.rs
Cargo.toml
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/bin/daemon/wayland/audio/fifo.rs">
use anyhow::{anyhow, Result};
use std::os::unix::io::{AsRawFd, RawFd};

const N_SAMPLES: usize = 44100 / 25;

#[derive(Debug)]
pub struct StereoSample {
    pub left: Vec<i16>,
    pub right: Vec<i16>,
}

impl StereoSample {
    pub fn new() -> Self {
        Self {
            left: vec![0; N_SAMPLES],
            right: vec![0; N_SAMPLES],
        }
    }
}

pub struct FifoReader {
    pub fd: RawFd,
}

impl FifoReader {
    pub fn new(fifo_path: &str) -> Result<Self> {
        use std::os::unix::fs::OpenOptionsExt;
        let file = std::fs::OpenOptions::new()
            .read(true)
            .custom_flags(libc::O_NONBLOCK)
            .open(fifo_path)?;

        Ok(Self {
            fd: file.as_raw_fd(),
        })
    }

    pub fn read_sample(&mut self) -> Result<Option<StereoSample>> {
        let mut buffer = vec![0u8; N_SAMPLES * 4];

        let bytes_read = unsafe {
            libc::read(
                self.fd,
                buffer.as_mut_ptr() as *mut libc::c_void,
                buffer.len(),
            )
        };

        if bytes_read < 0 {
            let errno = unsafe { *libc::__errno_location() };
            if errno == libc::EAGAIN || errno == libc::EWOULDBLOCK {
                return Ok(None);
            }
            return Err(anyhow!("Failed to read from FIFO: {}", errno));
        }

        if bytes_read == 0 {
            return Ok(None);
        }

        let samples_read = bytes_read as usize / 4;
        let mut stereo = StereoSample::new();

        for i in 0..samples_read.min(N_SAMPLES / 2) {
            let base = i * 4;
            if base + 3 < buffer.len() {
                stereo.left[i] = i16::from_le_bytes([buffer[base], buffer[base + 1]]);
                stereo.right[i] = i16::from_le_bytes([buffer[base + 2], buffer[base + 3]]);
            }
        }

        Ok(Some(stereo))
    }
}
</file>

<file path="src/bin/daemon/wayland/audio/mod.rs">
pub mod fifo;

pub use fifo::FifoReader;
</file>

<file path="src/bin/daemon/wayland/monitors/manager.rs">
use std::collections::HashMap;
use anyhow::Result;
use khronos_egl as egl;
use wayland_client::{Connection, QueueHandle};
use wayland_client::protocol::wl_compositor;
use wayland_protocols_wlr::layer_shell::v1::client::zwlr_layer_shell_v1;
use crate::media::MediaType;
use crate::wayland::rendering::surface::WaylandSurface;
use crate::wayland::types::{OutputInfo, RenderContext};
use crate::wayland::protocol::events::AppState;
use crate::wayland::traits::{WaylandSurface as WaylandSurfaceTrait, MediaRenderer as MediaRendererTrait};
use crate::wayland::audio::FifoReader;

pub struct MonitorManager {
    surfaces: HashMap<String, WaylandSurface>,
    egl_instance: egl::Instance<egl::Static>,
}

impl MonitorManager {
    pub fn new() -> Self {
        Self {
            surfaces: HashMap::new(),
            egl_instance: egl::Instance::new(egl::Static),
        }
    }

    pub fn create_surface(
        &mut self,
        output_info: &OutputInfo,
        compositor: &wl_compositor::WlCompositor,
        layer_shell: &zwlr_layer_shell_v1::ZwlrLayerShellV1,
        layer_name: Option<&str>,
        media_type: MediaType,
        conn: &Connection,
        qh: &QueueHandle<AppState>,
        fps: u16,
    ) -> Result<()> {
        let surface = WaylandSurface::new(
            output_info,
            compositor,
            layer_shell,
            layer_name,
            media_type,
            &self.egl_instance,
            conn,
            qh,
            fps,
        )?;

        let output_name = surface.get_output_name().to_string();
        self.surfaces.insert(output_name, surface);
        Ok(())
    }

    pub fn surfaces_mut(&mut self) -> impl Iterator<Item = &mut WaylandSurface> {
        self.surfaces.values_mut()
    }

    pub fn update_media(&mut self, target_monitors: Option<&[String]>, media_type: MediaType, fps: u16) -> Result<()> {
        match target_monitors {
            None => {
                // Apply to ALL monitors
                tracing::info!(
                    event = "media_update_all",
                    ?media_type,
                    monitors = self.surfaces.len(),
                    available_monitors = ?self.surfaces.keys().collect::<Vec<_>>(),
                    "Updating media on all monitors"
                );
                for (monitor_name, surface) in &mut self.surfaces {
                    tracing::debug!(
                        event = "media_update_monitor",
                        monitor = %monitor_name,
                        "Applying media to monitor"
                    );
                    MediaRendererTrait::update_media(&mut surface.renderer, media_type.clone(), fps)?;
                }
            }
            Some(target_names) => {
                // Apply to specific monitors
                tracing::info!(
                    event = "media_update_targeted",
                    targets = ?target_names,
                    ?media_type,
                    available_monitors = ?self.surfaces.keys().collect::<Vec<_>>(),
                    "Updating media on specific monitors"
                );
                
                let mut found_monitors = Vec::new();
                let mut missing_monitors = Vec::new();
                
                for target_name in target_names {
                    if let Some(surface) = self.surfaces.get_mut(target_name) {
                        tracing::debug!(
                            event = "media_update_monitor",
                            monitor = %target_name,
                            "Applying media to target monitor"
                        );
                        MediaRendererTrait::update_media(&mut surface.renderer, media_type.clone(), fps)?;
                        found_monitors.push(target_name);
                    } else {
                        missing_monitors.push(target_name);
                    }
                }
                
                if !missing_monitors.is_empty() {
                    tracing::warn!(
                        event = "monitors_not_found",
                        missing = ?missing_monitors,
                        found = ?found_monitors,
                        available = ?self.surfaces.keys().collect::<Vec<_>>(),
                        "Some target monitors were not found"
                    );
                }
                
                if found_monitors.is_empty() {
                    tracing::error!(
                        event = "no_monitors_updated",
                        targets = ?target_names,
                        available = ?self.surfaces.keys().collect::<Vec<_>>(),
                        "No target monitors were found - no media was updated"
                    );
                }
            }
        }
        Ok(())
    }

    pub fn set_swap_intervals(&self, has_video: bool, fps: u16) -> Result<()> {
        for surface in self.surfaces.values() {
            if has_video {
                self.egl_instance.swap_interval(surface.egl_resources.display, 1)?;
            } else {
                let interval = if fps == 0 { 1 } else { 0 };
                self.egl_instance.swap_interval(surface.egl_resources.display, interval)?;
            }
        }
        Ok(())
    }

    pub fn render_all(&mut self, mut fifo_reader: Option<&mut FifoReader>) -> Result<bool> {
        let mut any_updated = false;
        
        // We need to iterate over surfaces individually to handle EGL context switching
        let surface_names: Vec<String> = self.surfaces.keys().cloned().collect();
        
        for surface_name in surface_names {
            if let Some(surface) = self.surfaces.get_mut(&surface_name) {
                // Make the EGL context current for this specific surface
                self.egl_instance.make_current(
                    surface.egl_resources.display,
                    Some(surface.egl_resources.surface),
                    Some(surface.egl_resources.surface),
                    Some(surface.egl_resources.context),
                )?;

                // Check if this renderer has new frames
                if surface.renderer.has_new_frame() {
                    any_updated = true;
                }

                // Create a fresh render context for this surface
                let mut surface_context = RenderContext {
                    width: surface.current_width as i32,
                    height: surface.current_height as i32,
                    transform: surface.output_info.config.transform,
                    fifo_reader: fifo_reader.as_deref_mut(),
                };

                // Directly call the draw method on the renderer with proper context
                surface.renderer.draw(&mut surface_context)?;
                
                // Swap buffers for this surface
                self.egl_instance.swap_buffers(surface.egl_resources.display, surface.egl_resources.surface)?;
                
                tracing::trace!(
                    event = "surface_rendered",
                    monitor = %surface_name,
                    width = surface.current_width,
                    height = surface.current_height,
                    "Successfully rendered frame"
                );
            }
        }
        
        Ok(any_updated)
    }

    pub fn len(&self) -> usize {
        self.surfaces.len()
    }
}
</file>

<file path="src/bin/daemon/wayland/monitors/mod.rs">
pub mod manager;

pub use manager::MonitorManager;
</file>

<file path="src/bin/daemon/wayland/protocol/events.rs">
use crate::wayland::types::{DisplayConfig, OutputInfo};
use std::collections::HashMap;
use tracing::{debug, info};
use wayland_client::protocol::{wl_compositor, wl_output, wl_region, wl_registry, wl_surface};
use wayland_client::{Connection, Dispatch, Proxy, QueueHandle};
use wayland_protocols::xdg::xdg_output::zv1::client::{zxdg_output_manager_v1, zxdg_output_v1};
use wayland_protocols_wlr::layer_shell::v1::client::{zwlr_layer_shell_v1, zwlr_layer_surface_v1};

pub struct AppState {
    pub outputs: HashMap<u32, OutputInfo>,
    pub compositor: Option<wl_compositor::WlCompositor>,
    pub layer_shell: Option<zwlr_layer_shell_v1::ZwlrLayerShellV1>,
    pub output_manager: Option<zxdg_output_manager_v1::ZxdgOutputManagerV1>,
    pub configured_count: usize,
    pub total_surfaces: usize,
    pub layer_surface_configs: HashMap<u32, (u32, u32)>,
    pub surface_to_output: HashMap<u32, String>,
}

impl AppState {
    pub fn new() -> Self {
        Self {
            outputs: HashMap::new(),
            compositor: None,
            layer_shell: None,
            output_manager: None,
            configured_count: 0,
            total_surfaces: 0,
            layer_surface_configs: HashMap::new(),
            surface_to_output: HashMap::new(),
        }
    }
}

impl Dispatch<wl_registry::WlRegistry, ()> for AppState {
    fn event(
        state: &mut Self,
        registry: &wl_registry::WlRegistry,
        event: wl_registry::Event,
        _: &(),
        _: &Connection,
        qh: &QueueHandle<AppState>,
    ) {
        match event {
            wl_registry::Event::Global {
                name,
                interface,
                version,
            } => {
                debug!("Global: {} {} {}", name, interface, version);
                match interface.as_str() {
                    "wl_output" => {
                        let output =
                            registry.bind::<wl_output::WlOutput, _, _>(name, version, qh, name);
                        state.outputs.insert(
                            name,
                            OutputInfo {
                                output,
                                config: DisplayConfig {
                                    width: 0,
                                    height: 0,
                                    scale: 1,
                                    transform: wl_output::Transform::Normal,
                                    logical_width: None,
                                    logical_height: None,
                                },
                                name: None,
                            },
                        );
                    }
                    "wl_compositor" => {
                        state.compositor =
                            Some(registry.bind::<wl_compositor::WlCompositor, _, _>(
                                name,
                                version,
                                qh,
                                (),
                            ));
                    }
                    "zwlr_layer_shell_v1" => {
                        state.layer_shell = Some(
                            registry.bind::<zwlr_layer_shell_v1::ZwlrLayerShellV1, _, _>(
                                name,
                                version,
                                qh,
                                (),
                            ),
                        );
                    }
                    "zxdg_output_manager_v1" => {
                        state.output_manager = Some(
                            registry.bind::<zxdg_output_manager_v1::ZxdgOutputManagerV1, _, _>(
                                name,
                                version,
                                qh,
                                (),
                            ),
                        );
                    }
                    _ => {}
                }
            }
            wl_registry::Event::GlobalRemove { name } => {
                state.outputs.remove(&name);
            }
            _ => {}
        }
    }
}

impl Dispatch<wl_output::WlOutput, u32> for AppState {
    fn event(
        state: &mut Self,
        _: &wl_output::WlOutput,
        event: wl_output::Event,
        id: &u32,
        _: &Connection,
        _: &QueueHandle<AppState>,
    ) {
        if let Some(info) = state.outputs.get_mut(id) {
            match event {
                wl_output::Event::Geometry { transform, .. } => {
                    info.config.transform = transform
                        .into_result()
                        .unwrap_or(wl_output::Transform::Normal);
                }
                wl_output::Event::Scale { factor } => {
                    info.config.scale = factor;
                }
                wl_output::Event::Mode {
                    flags,
                    width,
                    height,
                    ..
                } => {
                    if let Ok(m) = flags.into_result() {
                        if m.contains(wl_output::Mode::Current) {
                            info.config.width = width as u32;
                            info.config.height = height as u32;
                        }
                    }
                }
                _ => {}
            }
        }
    }
}

impl Dispatch<zxdg_output_v1::ZxdgOutputV1, u32> for AppState {
    fn event(
        state: &mut Self,
        _: &zxdg_output_v1::ZxdgOutputV1,
        event: zxdg_output_v1::Event,
        output_id: &u32,
        _: &Connection,
        _: &QueueHandle<AppState>,
    ) {
        match event {
            zxdg_output_v1::Event::Name { name } => {
                if let Some(output_info) = state.outputs.get_mut(output_id) {
                    output_info.name = Some(name);
                }
            }
            zxdg_output_v1::Event::LogicalSize { width, height } => {
                if let Some(output_info) = state.outputs.get_mut(output_id) {
                    output_info.config.logical_width = Some(width as u32);
                    output_info.config.logical_height = Some(height as u32);
                    debug!(
                        "Output {} logical size: {}x{}",
                        output_info.name.as_deref().unwrap_or("unknown"),
                        width,
                        height
                    );
                }
            }
            _ => {}
        }
    }
}

impl Dispatch<zwlr_layer_surface_v1::ZwlrLayerSurfaceV1, Option<String>> for AppState {
    fn event(
        state: &mut Self,
        surface: &zwlr_layer_surface_v1::ZwlrLayerSurfaceV1,
        event: zwlr_layer_surface_v1::Event,
        output_name: &Option<String>,
        _: &Connection,
        _: &QueueHandle<AppState>,
    ) {
        match event {
            zwlr_layer_surface_v1::Event::Configure {
                serial,
                width,
                height,
            } => {
                surface.ack_configure(serial);
                let surface_id = surface.id().protocol_id();
                let output_name = output_name
                    .clone()
                    .unwrap_or_else(|| format!("unknown-{}", surface_id));

                info!(
                    "Layer surface {} (output {}) configured: {}x{}",
                    surface_id, output_name, width, height
                );

                state
                    .layer_surface_configs
                    .insert(surface_id, (width, height));
                state.surface_to_output.insert(surface_id, output_name);
                state.configured_count += 1;
            }
            _ => {}
        }
    }
}

// Implement remaining Dispatch traits
impl Dispatch<wl_compositor::WlCompositor, ()> for AppState {
    fn event(
        _: &mut Self,
        _: &wl_compositor::WlCompositor,
        _: wl_compositor::Event,
        _: &(),
        _: &Connection,
        _: &QueueHandle<AppState>,
    ) {
    }
}

impl Dispatch<zwlr_layer_shell_v1::ZwlrLayerShellV1, ()> for AppState {
    fn event(
        _: &mut Self,
        _: &zwlr_layer_shell_v1::ZwlrLayerShellV1,
        _: zwlr_layer_shell_v1::Event,
        _: &(),
        _: &Connection,
        _: &QueueHandle<AppState>,
    ) {
    }
}

impl Dispatch<zxdg_output_manager_v1::ZxdgOutputManagerV1, ()> for AppState {
    fn event(
        _: &mut Self,
        _: &zxdg_output_manager_v1::ZxdgOutputManagerV1,
        _: zxdg_output_manager_v1::Event,
        _: &(),
        _: &Connection,
        _: &QueueHandle<AppState>,
    ) {
    }
}

impl Dispatch<wl_surface::WlSurface, ()> for AppState {
    fn event(
        _: &mut Self,
        _: &wl_surface::WlSurface,
        _: wl_surface::Event,
        _: &(),
        _: &Connection,
        _: &QueueHandle<AppState>,
    ) {
    }
}

impl Dispatch<wl_region::WlRegion, ()> for AppState {
    fn event(
        _: &mut Self,
        _: &wl_region::WlRegion,
        _: wl_region::Event,
        _: &(),
        _: &Connection,
        _: &QueueHandle<AppState>,
    ) {
    }
}
</file>

<file path="src/bin/daemon/wayland/protocol/mod.rs">
pub mod state;
pub mod events;

pub use state::ProtocolState;
</file>

<file path="src/bin/daemon/wayland/protocol/state.rs">
use std::collections::HashMap;
use wayland_client::{Connection, QueueHandle};
use crate::wayland::types::{OutputId, OutputInfo, ProtocolGlobals, SurfaceState, SurfaceId};

/// Manages the overall protocol state
pub struct ProtocolState {
    pub outputs: HashMap<OutputId, OutputInfo>,
    pub surfaces: HashMap<SurfaceId, SurfaceState>, 
    pub globals: ProtocolGlobals,
    pub configured_count: usize,
    pub total_surfaces: usize,
    pub layer_surface_configs: HashMap<u32, (u32, u32)>,
    pub surface_to_output: HashMap<u32, String>,
}

impl ProtocolState {
    pub fn new() -> Self {
        Self {
            outputs: HashMap::new(),
            surfaces: HashMap::new(),
            globals: ProtocolGlobals {
                compositor: None,
                layer_shell: None,
                output_manager: None,
            },
            configured_count: 0,
            total_surfaces: 0,
            layer_surface_configs: HashMap::new(),
            surface_to_output: HashMap::new(),
        }
    }

    pub fn add_output(&mut self, id: OutputId, info: OutputInfo) {
        self.outputs.insert(id, info);
    }

    pub fn remove_output(&mut self, id: OutputId) {
        self.outputs.remove(&id);
    }

    pub fn get_output(&self, id: OutputId) -> Option<&OutputInfo> {
        self.outputs.get(&id)
    }

    pub fn get_output_mut(&mut self, id: OutputId) -> Option<&mut OutputInfo> {
        self.outputs.get_mut(&id)
    }

    pub fn add_surface(&mut self, surface: SurfaceState) {
        self.surfaces.insert(surface.id, surface);
        self.total_surfaces += 1;
    }

    pub fn get_surface(&self, id: SurfaceId) -> Option<&SurfaceState> {
        self.surfaces.get(&id)
    }

    pub fn get_surface_mut(&mut self, id: SurfaceId) -> Option<&mut SurfaceState> {
        self.surfaces.get_mut(&id)
    }

    pub fn configure_surface(&mut self, id: SurfaceId, width: u32, height: u32) {
        if let Some(surface) = self.surfaces.get_mut(&id) {
            surface.configured = true;
            self.configured_count += 1;
        }
        self.layer_surface_configs.insert(id.0, (width, height));
    }

    pub fn is_ready(&self) -> bool {
        self.configured_count >= self.total_surfaces && self.total_surfaces > 0
    }

    pub fn bind_globals(
        &mut self,
        conn: &Connection,
        qh: &QueueHandle<crate::wayland::protocol::events::AppState>,
    ) -> anyhow::Result<()> {
        let _registry = conn.display().get_registry(qh, ());
        Ok(())
    }
}
</file>

<file path="src/bin/daemon/wayland/rendering/mod.rs">
pub mod renderer;
pub mod surface;

pub use renderer::MediaRenderer;
</file>

<file path="src/bin/daemon/wayland/rendering/renderer.rs">
use crate::gl_bindings as gl;
use crate::media::{ImageHandler, MediaHandler, MediaType, ShaderHandler, VideoHandler};
use crate::utils;
use crate::wayland::types::RenderContext;
use anyhow::Result;
use std::ffi::CString;

pub enum MediaObject {
    Shader(ShaderHandler),
    Image(ImageHandler),
    Video(VideoHandler),
}

impl MediaObject {
    fn get_texture(&self) -> Option<u32> {
        match self {
            MediaObject::Shader(h) => h.get_texture(),
            MediaObject::Image(h) => h.get_texture(),
            MediaObject::Video(h) => h.get_texture(),
        }
    }

    fn get_dimensions(&self) -> (u32, u32) {
        match self {
            MediaObject::Shader(h) => h.get_dimensions(),
            MediaObject::Image(h) => h.get_dimensions(),
            MediaObject::Video(h) => h.get_dimensions(),
        }
    }

    fn update(&mut self) -> Result<bool> {
        match self {
            MediaObject::Shader(h) => h.update(),
            MediaObject::Image(h) => h.update(),
            MediaObject::Video(h) => h.update(),
        }
    }

    fn has_new_frame(&self) -> bool {
        match self {
            MediaObject::Shader(h) => h.has_new_frame(),
            MediaObject::Image(h) => h.has_new_frame(),
            MediaObject::Video(h) => h.has_new_frame(),
        }
    }

    fn get_shader_program(&self) -> u32 {
        match self {
            MediaObject::Shader(h) => h.get_shader_program(),
            MediaObject::Image(h) => h.get_shader_program(),
            MediaObject::Video(h) => h.get_shader_program(),
        }
    }
}

pub struct MediaRenderer {
    media_object: Option<MediaObject>,
    pending_media_type: Option<(MediaType, u16)>,
    vbo: u32,
    ebo: u32,
    vao: u32,
    start_time: u64,
    needs_resource_refresh: bool,
}

impl MediaRenderer {
    pub fn new(media_type: MediaType, fps: u16) -> Result<Self> {
        tracing::info!(
            event = "renderer_create",
            ?media_type,
            fps,
            "Creating MediaRenderer"
        );

        let start_time = utils::get_time_millis();
        Self::initialize_gl()?;
        let (vbo, ebo, vao) = Self::setup_geometry()?;

        tracing::debug!(
            event = "renderer_ready",
            vbo,
            ebo,
            vao,
            "Renderer initialized (media will be created on first draw)"
        );

        Ok(Self {
            media_object: None,
            pending_media_type: Some((media_type, fps)),
            vbo,
            ebo,
            vao,
            start_time,
            needs_resource_refresh: false,
        })
    }

    fn initialize_gl() -> Result<()> {
        unsafe {
            gl::load_with(|s| {
                let c_str = CString::new(s).unwrap();
                let proc_addr = match std::ffi::CStr::from_bytes_with_nul(b"eglGetProcAddress\0") {
                    Ok(name) => libc::dlsym(libc::RTLD_DEFAULT, name.as_ptr()),
                    Err(_) => std::ptr::null_mut(),
                };
                if proc_addr.is_null() {
                    std::ptr::null()
                } else {
                    let get_proc_addr: extern "C" fn(*const i8) -> *const std::ffi::c_void =
                        std::mem::transmute(proc_addr);
                    get_proc_addr(c_str.as_ptr())
                }
            });
            gl::ClearColor(0.0, 0.0, 0.0, 1.0);
        }
        Ok(())
    }

    fn create_media_object(media_type: MediaType, fps: u16) -> Result<MediaObject> {
        match media_type {
            MediaType::Shader(path) => {
                let shader_path = if path == "default" {
                    None
                } else {
                    Some(path.as_str())
                };
                Ok(MediaObject::Shader(ShaderHandler::new(shader_path)?))
            }
            MediaType::Image { path, shader } => Ok(MediaObject::Image(ImageHandler::new(
                &path,
                shader.as_deref(),
            )?)),
            MediaType::Video { path, shader } => {
                let forced_fps = if fps > 0 { Some(fps as f64) } else { None };
                Ok(MediaObject::Video(VideoHandler::new(
                    &path,
                    shader.as_deref(),
                    forced_fps,
                )?))
            }
        }
    }

    pub fn has_new_frame(&self) -> bool {
        if let Some(ref media_object) = self.media_object {
            media_object.has_new_frame()
        } else {
            false
        }
    }

    pub fn update_media(&mut self, new_media_type: MediaType, fps: u16) -> Result<()> {
        tracing::info!(
            event = "renderer_media_update",
            ?new_media_type,
            fps,
            "Updating renderer media"
        );

        self.pending_media_type = Some((new_media_type, fps));
        self.needs_resource_refresh = true;

        tracing::debug!(
            event = "renderer_media_scheduled",
            "Media update scheduled for next draw call"
        );
        Ok(())
    }

    fn ensure_resources(&mut self) -> Result<()> {
        if let Some((media_type, fps)) = self.pending_media_type.take() {
            tracing::debug!(
                event = "creating_media_object",
                ?media_type,
                "Creating media object in current GL context"
            );

            self.media_object = Some(Self::create_media_object(media_type, fps)?);

            tracing::debug!(
                event = "media_object_created",
                dimensions = ?self.media_object.as_ref().map(|m| m.get_dimensions()),
                has_texture = self.media_object.as_ref().map(|m| m.get_texture().is_some()),
                "Media object created successfully"
            );
        }

        if self.needs_resource_refresh {
            tracing::debug!(
                event = "refreshing_gl_resources",
                "Refreshing OpenGL resources for current context"
            );

            unsafe {
                if self.vao != 0 {
                    gl::DeleteVertexArrays(1, &self.vao);
                }
                if self.vbo != 0 {
                    gl::DeleteBuffers(1, &self.vbo);
                }
                if self.ebo != 0 {
                    gl::DeleteBuffers(1, &self.ebo);
                }
            }

            let (vbo, ebo, vao) = Self::setup_geometry()?;
            self.vbo = vbo;
            self.ebo = ebo;
            self.vao = vao;
            self.needs_resource_refresh = false;

            tracing::debug!(
                event = "gl_resources_refreshed",
                vbo = self.vbo,
                ebo = self.ebo,
                vao = self.vao,
                "OpenGL resources refreshed"
            );
        }
        Ok(())
    }

    fn update_geometry(&self, output_width: i32, output_height: i32) {
        let output_w = output_width as f32;
        let output_h = output_height as f32;

        let (media_width, media_height) = if let Some(ref media_object) = self.media_object {
            media_object.get_dimensions()
        } else {
            (0, 0)
        };

        let media_w = media_width as f32;
        let media_h = media_height as f32;

        if media_w <= 0.0 || media_h <= 0.0 {
            let verts: [f32; 16] = [
                -1.0, 1.0, 0.0, 0.0, -1.0, -1.0, 0.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0,
            ];

            unsafe {
                gl::BindBuffer(gl::ARRAY_BUFFER, self.vbo);
                gl::BufferData(
                    gl::ARRAY_BUFFER,
                    (verts.len() * std::mem::size_of::<f32>()) as isize,
                    verts.as_ptr() as *const _,
                    gl::STATIC_DRAW,
                );
            }
            return;
        }

        let media_aspect = media_w / media_h;
        let output_aspect = output_w / output_h;

        let (scale_x, scale_y) = if media_aspect > output_aspect {
            let scale = output_h / media_h;
            let scaled_width = media_w * scale;
            let overflow = (scaled_width - output_w) / output_w;
            (1.0 + overflow, 1.0)
        } else {
            let scale = output_w / media_w;
            let scaled_height = media_h * scale;
            let overflow = (scaled_height - output_h) / output_h;
            (1.0, 1.0 + overflow)
        };

        let u_min = (1.0 - 1.0 / scale_x) * 0.5;
        let u_max = 1.0 - u_min;
        let v_min = (1.0 - 1.0 / scale_y) * 0.5;
        let v_max = 1.0 - v_min;

        let verts: [f32; 16] = [
            -1.0, 1.0, u_min, v_min, -1.0, -1.0, u_min, v_max, 1.0, -1.0, u_max, v_max, 1.0, 1.0,
            u_max, v_min,
        ];

        unsafe {
            gl::BindBuffer(gl::ARRAY_BUFFER, self.vbo);
            gl::BufferData(
                gl::ARRAY_BUFFER,
                (verts.len() * std::mem::size_of::<f32>()) as isize,
                verts.as_ptr() as *const _,
                gl::STATIC_DRAW,
            );
        }
    }

    fn setup_geometry() -> Result<(u32, u32, u32)> {
        let vertices: [f32; 16] = [
            -1.0, 1.0, 0.0, 0.0, -1.0, -1.0, 0.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0,
        ];

        let indices: [u32; 6] = [0, 1, 2, 2, 3, 0];

        unsafe {
            let mut vao = 0;
            gl::GenVertexArrays(1, &mut vao);
            gl::BindVertexArray(vao);
            utils::check_gl_error("BindVertexArray");

            let mut vbo = 0;
            gl::GenBuffers(1, &mut vbo);
            gl::BindBuffer(gl::ARRAY_BUFFER, vbo);
            gl::BufferData(
                gl::ARRAY_BUFFER,
                (vertices.len() * std::mem::size_of::<f32>()) as isize,
                vertices.as_ptr() as *const _,
                gl::STATIC_DRAW,
            );
            utils::check_gl_error("VBO setup");

            let mut ebo = 0;
            gl::GenBuffers(1, &mut ebo);
            gl::BindBuffer(gl::ELEMENT_ARRAY_BUFFER, ebo);
            gl::BufferData(
                gl::ELEMENT_ARRAY_BUFFER,
                (indices.len() * std::mem::size_of::<u32>()) as isize,
                indices.as_ptr() as *const _,
                gl::STATIC_DRAW,
            );
            utils::check_gl_error("EBO setup");

            gl::VertexAttribPointer(
                0,
                2,
                gl::FLOAT,
                gl::FALSE,
                4 * std::mem::size_of::<f32>() as i32,
                std::ptr::null(),
            );
            gl::EnableVertexAttribArray(0);

            gl::VertexAttribPointer(
                1,
                2,
                gl::FLOAT,
                gl::FALSE,
                4 * std::mem::size_of::<f32>() as i32,
                (2 * std::mem::size_of::<f32>()) as *const _,
            );
            gl::EnableVertexAttribArray(1);
            utils::check_gl_error("Vertex attributes setup");

            gl::BindVertexArray(0);

            tracing::debug!(
                event = "geometry_setup",
                vao,
                vbo,
                ebo,
                "Created OpenGL geometry resources"
            );

            Ok((vbo, ebo, vao))
        }
    }

    pub fn draw(&mut self, context: &mut RenderContext) -> Result<()> {
        self.ensure_resources()?;

        if self.media_object.is_none() {
            tracing::debug!(
                event = "no_media_object",
                "No media object available for rendering"
            );
            return Ok(());
        }

        unsafe {
            let shader_program = self.media_object.as_ref().unwrap().get_shader_program();

            let mut program_valid = 0;
            gl::GetProgramiv(shader_program, gl::LINK_STATUS, &mut program_valid);
            if program_valid == gl::FALSE as i32 {
                tracing::error!(
                    event = "invalid_shader_program",
                    program = shader_program,
                    "Shader program is not valid, skipping render"
                );
                return Ok(());
            }

            gl::UseProgram(shader_program);
            utils::check_gl_error("UseProgram");

            gl::Clear(gl::COLOR_BUFFER_BIT);
            utils::check_gl_error("Clear");

            gl::Viewport(0, 0, context.width, context.height);
            utils::check_gl_error("Viewport");

            let _ = self.media_object.as_mut().unwrap().update()?;

            self.set_uniforms(shader_program, context)?;

            let texture = self.media_object.as_ref().unwrap().get_texture();
            if let Some(texture) = texture {
                gl::ActiveTexture(gl::TEXTURE0);
                gl::BindTexture(gl::TEXTURE_2D, texture);
                utils::check_gl_error("BindTexture");

                let media_loc =
                    gl::GetUniformLocation(shader_program, b"u_media\0".as_ptr() as *const i8);
                if media_loc != -1 {
                    gl::Uniform1i(media_loc, 0);
                    utils::check_gl_error("Uniform1i media");
                }
            }

            self.update_geometry(context.width, context.height);

            gl::BindVertexArray(self.vao);
            utils::check_gl_error("BindVertexArray for draw");

            gl::DrawElements(gl::TRIANGLES, 6, gl::UNSIGNED_INT, std::ptr::null());
            utils::check_gl_error("DrawElements");

            gl::BindVertexArray(0);
        }
        Ok(())
    }
    fn set_uniforms(&self, shader_program: u32, context: &mut RenderContext) -> Result<()> {
        unsafe {
            let time_loc = gl::GetUniformLocation(shader_program, b"time\0".as_ptr() as *const i8);
            if time_loc != -1 {
                let time = (utils::get_time_millis() - self.start_time) as f32 / 1000.0;
                gl::Uniform1f(time_loc, time);
                utils::check_gl_error("Uniform1f time");
            }

            let resolution_loc =
                gl::GetUniformLocation(shader_program, b"resolution\0".as_ptr() as *const i8);
            if resolution_loc != -1 {
                gl::Uniform2f(resolution_loc, context.width as f32, context.height as f32);
                utils::check_gl_error("Uniform2f resolution");
            }

            if let Some(ref mut reader) = context.fifo_reader {
                let fifo_loc =
                    gl::GetUniformLocation(shader_program, b"fifo\0".as_ptr() as *const i8);
                if fifo_loc != -1 {
                    if let Ok(Some(sample)) = reader.read_sample() {
                        let left_val = if !sample.left.is_empty() {
                            sample.left[0] as f32
                        } else {
                            0.0
                        };
                        let right_val = if !sample.right.is_empty() {
                            sample.right[0] as f32
                        } else {
                            0.0
                        };
                        gl::Uniform2f(fifo_loc, right_val, left_val);
                        utils::check_gl_error("Uniform2f fifo");
                    }
                }
            }
        }
        Ok(())
    }
}

impl Drop for MediaRenderer {
    fn drop(&mut self) {
        unsafe {
            if self.vao != 0 {
                gl::DeleteVertexArrays(1, &self.vao);
            }
            if self.vbo != 0 {
                gl::DeleteBuffers(1, &self.vbo);
            }
            if self.ebo != 0 {
                gl::DeleteBuffers(1, &self.ebo);
            }
        }
    }
}

impl crate::wayland::traits::MediaRenderer for MediaRenderer {
    fn update_media(&mut self, media_type: MediaType, fps: u16) -> Result<()> {
        self.update_media(media_type, fps)
    }

    fn draw(&mut self, context: &RenderContext) -> Result<()> {
        let mut mutable_context = RenderContext {
            width: context.width,
            height: context.height,
            transform: context.transform,
            fifo_reader: None,
        };
        self.draw(&mut mutable_context)
    }

    fn has_new_frame(&self) -> bool {
        self.has_new_frame()
    }
}
</file>

<file path="src/bin/daemon/wayland/rendering/surface.rs">
use anyhow::{Result, anyhow};
use khronos_egl as egl;
use wayland_client::protocol::wl_compositor;
use wayland_client::{Connection, Proxy, QueueHandle};
use wayland_protocols_wlr::layer_shell::v1::client::{zwlr_layer_shell_v1, zwlr_layer_surface_v1};
use crate::media::MediaType;
use crate::wayland::rendering::MediaRenderer;
use crate::wayland::types::{OutputInfo, EglResources, SurfaceId};
use crate::wayland::protocol::events::AppState;

pub struct WaylandSurface {
    pub egl_resources: EglResources,
    pub renderer: MediaRenderer,
    pub output_info: OutputInfo,
    pub egl_window: wayland_egl::WlEglSurface,
    pub current_width: u32,
    pub current_height: u32,
    pub surface_id: SurfaceId,
    pub configured: bool,
    pub output_name: String,
}

impl WaylandSurface {
    pub fn new(
        output_info: &OutputInfo,
        compositor: &wl_compositor::WlCompositor,
        layer_shell: &zwlr_layer_shell_v1::ZwlrLayerShellV1,
        layer_name: Option<&str>,
        media_type: MediaType,
        egl_instance: &egl::Instance<egl::Static>,
        conn: &Connection,
        qh: &QueueHandle<AppState>,
        fps: u16,
    ) -> Result<Self> {
        let surface = compositor.create_surface(qh, ());
        let input_region = compositor.create_region(qh, ());
        surface.set_input_region(Some(&input_region));

        let layer = match layer_name {
            Some("top") => zwlr_layer_shell_v1::Layer::Top,
            Some("bottom") => zwlr_layer_shell_v1::Layer::Bottom,
            Some("overlay") => zwlr_layer_shell_v1::Layer::Overlay,
            Some("background") | None => zwlr_layer_shell_v1::Layer::Background,
            _ => zwlr_layer_shell_v1::Layer::Background,
        };

        let layer_surface = layer_shell.get_layer_surface(
            &surface,
            Some(&output_info.output),
            layer,
            "papyrust-daemon".to_string(),
            qh,
            output_info.name.clone(),
        );

        let surface_id = SurfaceId(layer_surface.id().protocol_id());
        let output_name = output_info
            .name
            .clone()
            .unwrap_or_else(|| format!("unknown-{}", surface_id.0));

        tracing::info!(
            event = "layer_surface_create",
            output = %output_name,
            surface_id = surface_id.0,
            layer = ?layer_name.unwrap_or("background"),
            "Created layer surface"
        );

        layer_surface.set_exclusive_zone(-1);
        layer_surface.set_anchor(
            zwlr_layer_surface_v1::Anchor::Top
                | zwlr_layer_surface_v1::Anchor::Left
                | zwlr_layer_surface_v1::Anchor::Right
                | zwlr_layer_surface_v1::Anchor::Bottom,
        );

        surface.commit();

        let egl_resources = Self::create_egl_resources(egl_instance, conn)?;
        let initial_width = 100;
        let initial_height = 100;

        let egl_window = wayland_egl::WlEglSurface::new(surface.id(), initial_width, initial_height)
            .map_err(|e| anyhow!("Failed to create wl_egl_window: {e}"))?;

        let egl_surface = unsafe {
            egl_instance.create_window_surface(
                egl_resources.display,
                egl_resources.config,
                egl_window.ptr() as *mut _,
                Some(&[egl::NONE]),
            )?
        };

        egl_instance.make_current(
            egl_resources.display,
            Some(egl_surface),
            Some(egl_surface),
            Some(egl_resources.context),
        )?;

        tracing::debug!(
            event = "egl_ready",
            output = %output_name,
            width = initial_width,
            height = initial_height,
            "EGL surface/context ready"
        );

        let renderer = MediaRenderer::new(media_type, fps)?;

        Ok(Self {
            egl_resources: EglResources {
                display: egl_resources.display,
                surface: egl_surface,
                context: egl_resources.context,
                config: egl_resources.config,
            },
            renderer,
            output_info: output_info.clone(),
            egl_window,
            current_width: initial_width as u32,
            current_height: initial_height as u32,
            surface_id,
            configured: false,
            output_name,
        })
    }

    fn create_egl_resources(
        egl_instance: &egl::Instance<egl::Static>,
        conn: &Connection,
    ) -> Result<EglResources> {
        let display_ptr = conn.display().id().as_ptr();
        let egl_display = unsafe { egl_instance.get_display(display_ptr as *mut _) }
            .ok_or_else(|| anyhow!("Failed to get EGL display for Wayland connection"))?;
        let _version = egl_instance.initialize(egl_display)?;

        egl_instance.bind_api(egl::OPENGL_ES_API)?;

        let config_attribs = [
            egl::SURFACE_TYPE,
            egl::WINDOW_BIT,
            egl::RENDERABLE_TYPE,
            egl::OPENGL_ES2_BIT,
            egl::RED_SIZE,
            8,
            egl::GREEN_SIZE,
            8,
            egl::BLUE_SIZE,
            8,
            egl::ALPHA_SIZE,
            8,
            egl::NONE,
        ];

        let mut configs = Vec::with_capacity(1);
        egl_instance.choose_config(egl_display, &config_attribs, &mut configs)?;
        let config = configs
            .first()
            .ok_or_else(|| anyhow!("No suitable EGL config"))?;

        let context_attribs = [
            egl::CONTEXT_MAJOR_VERSION,
            2,
            egl::CONTEXT_MINOR_VERSION,
            0,
            egl::NONE,
        ];
        let context = egl_instance.create_context(egl_display, *config, None, &context_attribs)?;

        Ok(EglResources {
            display: egl_display,
            surface: unsafe { egl::Surface::from_ptr(std::ptr::null_mut()) },
            context,
            config: *config,
        })
    }
}

impl crate::wayland::traits::WaylandSurface for WaylandSurface {
    fn resize(&mut self, width: u32, height: u32) -> Result<()> {
        if self.current_width != width || self.current_height != height {
            tracing::info!(
                event = "surface_resize",
                output = %self.output_name,
                surface_id = self.surface_id.0,
                from_width = self.current_width,
                from_height = self.current_height,
                to_width = width,
                to_height = height,
                "Applying surface resize"
            );
            self.egl_window.resize(width as i32, height as i32, 0, 0);
            self.current_width = width;
            self.current_height = height;
            self.configured = true;
        } else {
            tracing::debug!(
                event = "surface_resize_skipped",
                output = %self.output_name,
                width,
                height,
                "Resize skipped (dimensions unchanged)"
            );
        }
        Ok(())
    }

    fn get_output_name(&self) -> &str {
        &self.output_name
    }
}
</file>

<file path="src/bin/daemon/wayland/traits.rs">
use anyhow::Result;
use crate::media::MediaType;
use super::types::RenderContext;

/// Trait for Wayland surface operations
pub trait WaylandSurface {
    fn resize(&mut self, width: u32, height: u32) -> Result<()>;
    fn get_output_name(&self) -> &str;
}

/// Trait for media rendering operations
pub trait MediaRenderer {
    fn update_media(&mut self, media_type: MediaType, fps: u16) -> Result<()>;
    fn draw(&mut self, context: &RenderContext) -> Result<()>;
    fn has_new_frame(&self) -> bool;
}
</file>

<file path="src/bin/daemon/wayland/types.rs">
use wayland_client::protocol::{wl_output, wl_compositor};
use wayland_protocols::xdg::xdg_output::zv1::client::zxdg_output_manager_v1;
use wayland_protocols_wlr::layer_shell::v1::client::{zwlr_layer_shell_v1, zwlr_layer_surface_v1};
use khronos_egl as egl;
use super::audio::fifo::FifoReader;

/// Unique identifier for outputs
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct OutputId(pub u32);

/// Unique identifier for surfaces  
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct SurfaceId(pub u32);

/// Display configuration for an output
#[derive(Debug, Clone)]
pub struct DisplayConfig {
    pub width: u32,
    pub height: u32,
    pub scale: i32,
    pub transform: wl_output::Transform,
    pub logical_width: Option<u32>,
    pub logical_height: Option<u32>,
}

/// Information about a Wayland output
#[derive(Debug, Clone)]
pub struct OutputInfo {
    pub output: wl_output::WlOutput,
    pub config: DisplayConfig,
    pub name: Option<String>,
}

/// Rendering context passed to draw operations
pub struct RenderContext<'a> {
    pub width: i32,
    pub height: i32,
    pub transform: wl_output::Transform,
    pub fifo_reader: Option<&'a mut FifoReader>,
}

/// EGL resources for a surface
pub struct EglResources {
    pub display: egl::Display,
    pub surface: egl::Surface,
    pub context: egl::Context,
    pub config: egl::Config,
}

/// Protocol state containing global Wayland objects
pub struct ProtocolGlobals {
    pub compositor: Option<wl_compositor::WlCompositor>,
    pub layer_shell: Option<zwlr_layer_shell_v1::ZwlrLayerShellV1>,
    pub output_manager: Option<zxdg_output_manager_v1::ZxdgOutputManagerV1>,
}

/// Surface state tracking
pub struct SurfaceState {
    pub id: SurfaceId,
    pub output_id: OutputId,
    pub output_name: String,
    pub layer_surface: zwlr_layer_surface_v1::ZwlrLayerSurfaceV1,
    pub configured: bool,
}

/// Configuration for the Wayland subsystem
#[derive(Debug, Clone)]
pub struct WaylandConfig {
    pub fps: u16,
    pub layer_name: Option<String>,
    pub fifo_path: Option<String>,
    pub mute: bool,
    pub sharpening: f32,
}
</file>

<file path="shaders/plasma.frag">
#ifdef GL_ES
precision mediump float;
#endif

uniform float time;
uniform vec2 resolution;
varying vec2 texCoords;

void main() {
    vec2 uv = texCoords;
    vec2 p = (uv - 0.5) * vec2(resolution.x/resolution.y, 1.0) * 2.0;

    float v1 = sin(p.x * 3.0 + time);
    float v2 = sin((p.x * cos(time*0.7) + p.y * sin(time*0.3)) * 4.0);
    float v3 = sin(length(p) * 5.0 - time * 1.5);

    float v = (v1 + v2 + v3) / 3.0;

    vec3 col = vec3(
        0.5 + 0.5 * sin(3.0 + v * 3.0),
        0.5 + 0.5 * sin(1.0 + v * 3.0),
        0.5 + 0.5 * sin(5.0 + v * 3.0)
    );

    gl_FragColor = vec4(col, 1.0);
}
</file>

<file path="shaders/rainbow.frag">
#version 100
precision mediump float;

uniform float time;
uniform vec2 resolution;

void main() {
    vec2 uv = gl_FragCoord.xy / resolution;

    float wave = 0.5 + 0.5 * sin(uv.x * 10.0 + time);

    gl_FragColor = vec4(uv.x, uv.y, wave, 1.0);
}
</file>

<file path="src/ui/components/lib_popup.rs">
use iced::{
    alignment::{Horizontal, Vertical},
    widget::{button, mouse_area, text, Button, Column, Container, Row, Space},
    Background, Border, Color, Element, Length, Padding, Shadow, Vector,
};
use iced_video_player::VideoPlayer;

use crate::{ui::loader::project::Project, Message, Papyrust};

pub fn build<'a>(app: &'a Papyrust, project: &'a Project) -> Element<'a, Message> {
    let title = project.meta.title.as_deref().unwrap_or("Untitled");

    let video_preview = create_preview(app, project);

    let close_button = Button::new(text("Close").size(16))
        .on_press(Message::ClosePopup)
        .padding(Padding::from([8, 12]))
        .style(|_theme, status| {
            let base = Color::from_rgba(0.2, 0.2, 0.2, 0.8);
            let hover = Color::from_rgba(0.3, 0.3, 0.3, 0.9);
            let border_color = Color::from_rgba(0.6, 0.6, 0.6, 0.5);

            button::Style {
                background: Some(Background::Color(
                    if matches!(status, iced::widget::button::Status::Hovered) {
                        hover
                    } else {
                        base
                    },
                )),
                border: Border {
                    radius: 8.0.into(),
                    width: 1.0,
                    color: border_color,
                },
                text_color: Color::WHITE,
                ..Default::default()
            }
        });

    let apply_button = Button::new(text("Apply").size(16))
        .padding(Padding::from([8, 12]))
        .on_press(Message::ApplyProject(project.clone()))
        .style(|_theme, status| {
            let base = Color::from_rgba(0.2, 0.2, 0.2, 0.8);
            let hover = Color::from_rgba(0.3, 0.3, 0.3, 0.9);
            let border_color = Color::from_rgba(0.6, 0.6, 0.6, 0.5);

            button::Style {
                background: Some(Background::Color(
                    if matches!(status, iced::widget::button::Status::Hovered) {
                        hover
                    } else {
                        base
                    },
                )),
                border: Border {
                    radius: 8.0.into(),
                    width: 1.0,
                    color: border_color,
                },
                text_color: Color::WHITE,
                ..Default::default()
            }
        });

    let header = Row::new()
        .push(
            text(title)
                .size(24)
                .style(|_theme| iced::widget::text::Style {
                    color: Some(Color::WHITE),
                    ..Default::default()
                }),
        )
        .align_y(Vertical::Center);

    let footer_row = Row::new().spacing(10).push(close_button).push(apply_button);

    let footer = Container::new(footer_row)
        .align_x(Horizontal::Center)
        .width(Length::Fill);

    let popup_content = Column::new()
        .push(header)
        .push(video_preview)
        .push(Space::new(Length::Fill, Length::Fill))
        .push(footer)
        .spacing(20)
        .padding(20)
        .width(Length::Fill)
        .align_x(Horizontal::Center);

    let popup = Container::new(popup_content)
        .width(Length::Fixed(800.0))
        .height(Length::Fixed(600.0))
        .style(|_theme| iced::widget::container::Style {
            background: Some(Background::Color(Color::from_rgba(0.05, 0.05, 0.05, 0.98))),
            border: Border {
                radius: 16.0.into(),
                width: 2.0,
                color: Color::from_rgba(0.6, 0.6, 0.6, 0.4),
            },
            shadow: Shadow {
                color: Color::from_rgba(0.0, 0.0, 0.0, 0.5),
                offset: Vector::new(0.0, 8.0),
                blur_radius: 24.0,
            },
            ..Default::default()
        })
        .align_x(Horizontal::Center)
        .align_y(Vertical::Center);

    let protected = mouse_area(popup).on_press(Message::DoNothing);

    mouse_area(
        Container::new(protected)
            .width(Length::Fill)
            .height(Length::Fill)
            .style(|_theme| iced::widget::container::Style {
                background: Some(Background::Color(Color::from_rgba(0.0, 0.0, 0.0, 0.85))),
                ..Default::default()
            })
            .align_x(Horizontal::Center)
            .align_y(Vertical::Center),
    )
    .on_press(Message::ClosePopup)
    .into()
}

fn create_preview<'a>(app: &'a Papyrust, project: &'a Project) -> Element<'a, Message> {
    if let Some(file_name) = &project.meta.file {
        let video_path = format!("{}/{}", project.path, file_name);

        if let Some(video) = app.peek_video(&video_path) {
            let video_width = 720.0;
            let video_height = 405.0;

            Container::new(
                VideoPlayer::new(video)
                    .width(Length::Fixed(video_width))
                    .height(Length::Fixed(video_height)),
            )
            .width(Length::Fixed(video_width))
            .height(Length::Fixed(video_height))
            .style(|_theme| iced::widget::container::Style {
                background: Some(Background::Color(Color::from_rgba(0.0, 0.0, 0.0, 0.95))),
                border: Border {
                    radius: 12.0.into(),
                    width: 2.0,
                    color: Color::from_rgba(0.4, 0.4, 0.4, 0.5),
                },
                shadow: Shadow {
                    color: Color::from_rgba(0.0, 0.0, 0.0, 0.3),
                    offset: Vector::new(0.0, 4.0),
                    blur_radius: 12.0,
                },
                ..Default::default()
            })
            .align_x(Horizontal::Center)
            .align_y(Vertical::Center)
            .into()
        } else {
            let dots = match app.animation_state {
                0 => "Loading video.  ",
                1 => "Loading video.. ",
                2 => "Loading video...",
                _ => "Loading video   ",
            };

            let video_width = 720.0;
            let video_height = 405.0;

            Container::new(
                text(dots)
                    .size(18)
                    .style(|_theme| iced::widget::text::Style {
                        color: Some(Color::from_rgba(1.0, 1.0, 1.0, 0.8)),
                        ..Default::default()
                    }),
            )
            .width(Length::Fixed(video_width))
            .height(Length::Fixed(video_height))
            .style(|_theme| iced::widget::container::Style {
                background: Some(Background::Color(Color::from_rgba(0.15, 0.15, 0.15, 0.9))),
                border: Border {
                    radius: 12.0.into(),
                    width: 2.0,
                    color: Color::from_rgba(0.4, 0.4, 0.4, 0.5),
                },
                ..Default::default()
            })
            .align_x(Horizontal::Center)
            .align_y(Vertical::Center)
            .into()
        }
    } else {
        let video_width = 720.0;
        let video_height = 405.0;

        Container::new(text("No video available").size(18).style(|_theme| {
            iced::widget::text::Style {
                color: Some(Color::from_rgba(1.0, 1.0, 1.0, 0.8)),
                ..Default::default()
            }
        }))
        .width(Length::Fixed(video_width))
        .height(Length::Fixed(video_height))
        .style(|_theme| iced::widget::container::Style {
            background: Some(Background::Color(Color::from_rgba(0.15, 0.15, 0.15, 0.9))),
            border: Border {
                radius: 12.0.into(),
                width: 2.0,
                color: Color::from_rgba(0.4, 0.4, 0.4, 0.5),
            },
            ..Default::default()
        })
        .align_x(Horizontal::Center)
        .align_y(Vertical::Center)
        .into()
    }
}
</file>

<file path="src/ui/components/panel.rs">
use iced::{
    widget::{text, Button, Container, Row},
    Alignment, Element, Padding,
};

use crate::Message;

use crate::ui::state::Page;

pub fn build(_app: &crate::Papyrust) -> Element<Message> {
    let library = Button::new(text("Library"))
        .on_press(Message::SwitchPage(Page::Library))
        .padding(Padding::from([8, 16]));

    let discover = Button::new(text("Discover"))
        .on_press(Message::SwitchPage(Page::Discover))
        .padding(Padding::from([8, 16]));

    let content = Row::new()
        .push(library)
        .push(discover)
        .spacing(15)
        .align_y(Alignment::Center);

    Container::new(content)
        .padding(Padding::from([10, 20]))
        .into()
}
</file>

<file path="src/ui/loader/mod.rs">
use crate::ui::loader::project::{Project, ProjectMeta};
use std::{fs, path::PathBuf};

pub mod project;

const WALLPAPER_ENGINE_ID: &str = "431960";
const WORKSHOP_PATHS: [&str; 4] = [
    "~/.steam/steam/steamapps/workshop",
    "~/.local/share/Steam/steamapps/workshop",
    "~/.var/app/com.valvesoftware.Steam/.local/share/Steam/steamapps/workshop",
    "~/snap/steam/common/.local/share/Steam/steamapps/workshop",
];

fn resolve_paths() -> Vec<PathBuf> {
    WORKSHOP_PATHS
        .iter()
        .map(|p| shellexpand::tilde(p).to_string())
        .map(PathBuf::from)
        .filter(|p| p.exists())
        .map(|p| p.join("content").join(WALLPAPER_ENGINE_ID))
        .filter(|p| p.exists())
        .collect()
}

pub struct Loader {
    project_paths: Vec<PathBuf>,
    current: usize,
}

impl Loader {
    pub fn new() -> Self {
        let mut paths = Vec::new();

        for base in resolve_paths() {
            if let Ok(entries) = fs::read_dir(base) {
                for entry in entries.flatten() {
                    let dir = entry.path();
                    if dir.is_dir() && dir.join("project.json").exists() {
                        paths.push(dir);
                    }
                }
            }
        }

        Loader {
            project_paths: paths,
            current: 0,
        }
    }

    pub fn next(&mut self) -> Option<Result<Project, String>> {
        if self.current >= self.project_paths.len() {
            None
        } else {
            let dir = self.project_paths[self.current].clone();
            self.current += 1;
            let path = dir.join("project.json");
            Some(parse(&path, &dir))
        }
    }
}

fn parse(path: &PathBuf, dir: &PathBuf) -> Result<Project, String> {
    let content = fs::read_to_string(path)
        .map_err(|e| format!("Failed to read {}: {}", path.display(), e))?;

    let meta: ProjectMeta = serde_json::from_str(&content)
        .map_err(|e| format!("JSON parse error in {}: {}", path.display(), e))?;

    Ok(Project {
        meta,
        path: dir.to_string_lossy().to_string(),
    })
}
</file>

<file path="src/ui/loader/project.rs">
use serde::Deserialize;

#[derive(Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum ProjectType {
    #[serde(alias = "Web")]
    Web,
    #[serde(alias = "Video")]
    Video,
    #[serde(alias = "Application")]
    Application,
    #[serde(alias = "Scene")]
    Scene,
}

#[derive(Deserialize, Debug, Clone)]
pub struct ProjectMeta {
    pub title: Option<String>,
    pub description: Option<String>,
    pub tags: Option<Vec<String>>,
    #[serde(rename = "type")]
    pub file_type: Option<ProjectType>,
    pub preview: Option<String>,
    pub file: Option<String>,
}

#[derive(Clone, Debug)]
pub struct Project {
    pub meta: ProjectMeta,
    pub path: String,
}
</file>

<file path="src/ui/pages/discover.rs">
use iced::Element;

use crate::{Message, Papyrust};

pub fn build(_app: &Papyrust) -> Element<Message> {
    iced::widget::text("Discover").into()
}
</file>

<file path="src/ui/pages/mod.rs">
pub mod discover;
pub mod library;
</file>

<file path="build.rs">
use gl_generator::{Api, Fallbacks, Profile, Registry};
use std::env;
use std::fs::File;
use std::path::Path;

fn main() {
    let dest = env::var("OUT_DIR").unwrap();
    let mut file = File::create(&Path::new(&dest).join("gl_bindings.rs")).unwrap();

    Registry::new(Api::Gles2, (3, 0), Profile::Core, Fallbacks::All, [])
        .write_bindings(gl_generator::GlobalGenerator, &mut file)
        .unwrap();
}
</file>

<file path="src/bin/daemon/media/mod.rs">
use anyhow::Result;

#[derive(Debug, Clone, PartialEq)]
pub enum MediaType {
    Shader(String),
    Image {
        path: String,
        shader: Option<String>,
    },
    Video {
        path: String,
        shader: Option<String>,
    },
}

pub trait MediaHandler {
    fn get_texture(&self) -> Option<u32>;
    fn get_dimensions(&self) -> (u32, u32);
    fn update(&mut self) -> Result<bool>;
    fn has_new_frame(&self) -> bool;
}

pub mod image;
pub mod shader;
pub mod video;

pub use image::ImageHandler;
pub use shader::ShaderHandler;
pub use video::VideoHandler;
</file>

<file path="src/bin/daemon/media/shader.rs">
use anyhow::{anyhow, Result};
use std::fs::File;
use std::io::Read;
use crate::utils::{compile_shader, vertex_shader, default_shader, prepare_shader_source};
use crate::media::MediaHandler;

pub struct ShaderHandler {
    shader_program: u32,
}

impl ShaderHandler {
    pub fn new(path: Option<&str>) -> Result<Self> {
        tracing::info!(
            event = "shader_create",
            path = path.unwrap_or("default"),
            "Creating shader handler"
        );

        let shader_program = if let Some(shader_path) = path {
            if shader_path == "default" {
                Self::create_default_shader()?
            } else {
                Self::create_pure_shader(shader_path)?
            }
        } else {
            Self::create_default_shader()?
        };

        Ok(Self { shader_program })
    }

    pub fn get_shader_program(&self) -> u32 {
        self.shader_program
    }

    fn load_shader(path: &str) -> Result<String> {
        let mut file = File::open(path)
            .map_err(|e| anyhow!("Failed to open shader file {}: {}", path, e))?;
        let mut source = String::new();
        file.read_to_string(&mut source)
            .map_err(|e| anyhow!("Failed to read shader file {}: {}", path, e))?;
        Ok(source)
    }

    fn create_pure_shader(shader_path: &str) -> Result<u32> {
        let raw = Self::load_shader(shader_path)?;
        let frag_source = prepare_shader_source(&raw);
        
        let vert_source = r#"
            #version 100
            attribute highp vec2 datIn;
            attribute highp vec2 texIn;
            varying highp vec2 texCoords;
            void main() {
                texCoords = texIn;
                gl_Position = vec4(datIn, 0.0, 1.0);
            }
        "#;
        
        compile_shader(vert_source, &frag_source)
    }

    fn create_default_shader() -> Result<u32> {
        let vert_source = vertex_shader();
        let frag_source = default_shader();
        compile_shader(vert_source, frag_source)
    }

    pub fn create_media_shader(shader_path: &str) -> Result<u32> {
        let raw = Self::load_shader(shader_path)?;
        let frag_source = prepare_shader_source(&raw);
        let vert_source = vertex_shader();
        compile_shader(vert_source, &frag_source)
    }
}

impl MediaHandler for ShaderHandler {
    fn get_texture(&self) -> Option<u32> {
        None
    }

    fn get_dimensions(&self) -> (u32, u32) {
        (0, 0)
    }

    fn update(&mut self) -> Result<bool> {
        Ok(false)
    }

    fn has_new_frame(&self) -> bool {
        false
    }
}

impl Drop for ShaderHandler {
    fn drop(&mut self) {
        unsafe {
            crate::gl_bindings::DeleteProgram(self.shader_program);
        }
    }
}
</file>

<file path="src/ui/components/mod.rs">
pub mod lib_popup;
pub mod panel;
</file>

<file path="src/ui/pages/library.rs">
use iced::alignment::{Horizontal, Vertical};
use iced::widget::image::Handle;
use iced::widget::{Button, Column, Container};
use iced::{
    widget::{column, container, scrollable, text},
    Element, Length,
};
use iced::{Alignment, Padding, Task};
use image::{imageops, load_from_memory, RgbaImage};
use tokio::{fs, task};

use tracing::error;
use crate::ui::loader::project::{Project, ProjectType};
use crate::ui::loader::Loader;
use crate::{Message, Papyrust};

pub struct Library {
    pub projects: Vec<Project>,
    pub preview: Vec<Option<Handle>>,
}

const PREVIEW_WIDTH: f32 = 140.0;
const PREVIEW_HEIGHT: f32 = 140.0;

const ITEM_WIDTH: f32 = 160.0;
const ITEM_HEIGHT: f32 = 200.0;

impl Library {
    pub fn new() -> Self {
        let mut loader = Loader::new();
        let mut projects = Vec::new();
        let mut preview = Vec::new();

        while let Some(result) = loader.next() {
            match result {
                Ok(project) => {
                    // Skip for now all non-video projects
                    if project.meta.file_type != Some(ProjectType::Video) {
                        continue;
                    }
                    projects.push(project);
                    preview.push(None);
                }
                Err(e) => error!("Project parse error: {}", e),
            }
        }

        Self { projects, preview }
    }

    pub fn next(&mut self) -> Option<Task<Message>> {
        self.projects
            .iter()
            .enumerate()
            .find(|(idx, proj)| self.preview[*idx].is_none() && proj.meta.preview.is_some())
            .map(|(idx, proj)| {
                let name = proj.meta.preview.as_ref().unwrap().clone();
                let path = format!("{}/{}", proj.path, name);
                Task::perform(
                    async move {
                        let buf = fs::read(&path).await.ok();
                        if let Some(bytes) = buf {
                            let decode = task::spawn_blocking(move || {
                                let img = load_from_memory(&bytes).ok()?;
                                let mut rgba = img.to_rgba8();

                                // Ik this is not the most efficient way to handle this, but iced forces me to do it this way
                                rgba = Self::resize_image(rgba, PREVIEW_WIDTH as u32);
                                rgba = Self::round_image(rgba, 4.0);
                                let (w, h) = rgba.dimensions();
                                Some((w, h, rgba.into_raw()))
                            })
                            .await
                            .ok()
                            .flatten();

                            if let Some((w, h, pixels)) = decode {
                                return (idx, Ok((w, h, pixels)));
                            }
                        }
                        (idx, Err(()))
                    },
                    |(i, result)| match result {
                        Ok((w, h, pixels)) => Message::PreviewDecoded(i, w, h, pixels),
                        Err(_) => Message::PreviewError(i),
                    },
                )
            })
    }

    fn round_image(img: RgbaImage, radius: f32) -> RgbaImage {
        let (width, height) = img.dimensions();
        let mut rounded = img.clone();

        let radius_u32 = radius as u32;
        let right_bound = width.saturating_sub(radius_u32);
        let bottom_bound = height.saturating_sub(radius_u32);
        let radius_sq = radius * radius;

        let corners = [
            (0..radius_u32, 0..radius_u32),
            (right_bound..width, 0..radius_u32),
            (0..radius_u32, bottom_bound..height),
            (right_bound..width, bottom_bound..height),
        ];

        for (x_range, y_range) in corners {
            for y in y_range {
                for x in x_range.clone() {
                    let (dx, dy) = match (x < radius_u32, y < radius_u32) {
                        (true, true) => (radius - x as f32, radius - y as f32),
                        (false, true) => {
                            (x as f32 - (width as f32 - radius - 1.0), radius - y as f32)
                        }
                        (true, false) => {
                            (radius - x as f32, y as f32 - (height as f32 - radius - 1.0))
                        }
                        (false, false) => (
                            x as f32 - (width as f32 - radius - 1.0),
                            y as f32 - (height as f32 - radius - 1.0),
                        ),
                    };

                    if dx * dx + dy * dy > radius_sq {
                        rounded.get_pixel_mut(x, y)[3] = 0;
                    }
                }
            }
        }

        rounded
    }
    fn resize_image(img: RgbaImage, target_size: u32) -> RgbaImage {
        let (width, height) = img.dimensions();

        let scale = target_size as f32 / width.max(height) as f32;
        let new_width = (width as f32 * scale) as u32;
        let new_height = (height as f32 * scale) as u32;

        let src_image = fast_image_resize::images::Image::from_vec_u8(
            width,
            height,
            img.into_raw(),
            fast_image_resize::PixelType::U8x4,
        )
        .unwrap();

        let mut dst_image = fast_image_resize::images::Image::new(
            new_width,
            new_height,
            fast_image_resize::PixelType::U8x4,
        );

        let mut resizer = fast_image_resize::Resizer::new();

        let resize_options = fast_image_resize::ResizeOptions::new().resize_alg(
            fast_image_resize::ResizeAlg::Convolution(fast_image_resize::FilterType::Lanczos3),
        );

        resizer
            .resize(&src_image, &mut dst_image, Some(&resize_options))
            .unwrap();

        let resized_rgba =
            RgbaImage::from_raw(new_width, new_height, dst_image.into_vec()).unwrap();

        let crop_x = (new_width.saturating_sub(target_size)) / 2;
        let crop_y = (new_height.saturating_sub(target_size)) / 2;

        imageops::crop_imm(&resized_rgba, crop_x, crop_y, target_size, target_size).to_image()
    }
}

pub fn build(app: &Papyrust) -> Element<Message> {
    let lib = &app.library;
    let grid = crate::ui::view::create_grid(&app, &lib.projects, &lib.preview);

    container(scrollable(column![text("Library").size(30), grid]))
        .padding(20)
        .width(Length::Fill)
        .height(Length::Fill)
        .into()
}

pub fn render_item<'a>(
    app: &Papyrust,
    project: &'a Project,
    preview: Option<Handle>,
) -> Element<'a, Message> {
    let title = project.meta.title.as_deref().unwrap_or("Untitled");
    let preview = create_preview(app, preview, project);

    Button::new(
        Container::new(
            Column::new()
                .align_x(Alignment::Center)
                .padding(Padding::new(0.0).top(4.0))
                .push(preview)
                .push(
                    text(title)
                        .size(14)
                        .style(|_theme: &_| iced::widget::text::Style {
                            color: Some(iced::Color::WHITE),
                            ..Default::default()
                        })
                        .width(Length::Fixed(ITEM_WIDTH - 20.0))
                        .align_x(Alignment::Center),
                )
                .spacing(8),
        )
        .width(Length::Fixed(ITEM_WIDTH))
        .height(Length::Fixed(ITEM_HEIGHT)),
    )
    .width(Length::Fixed(ITEM_WIDTH))
    .height(Length::Fixed(ITEM_HEIGHT))
    .style(|_theme, status| {
        let base_color = iced::Color::from_rgba(0.0, 0.0, 0.0, 0.15);
        let hover_color = iced::Color::from_rgba(0.5, 0.5, 0.5, 0.3);
        let border_color = iced::Color::from_rgba(0.0, 0.0, 0.0, 0.2);

        match status {
            iced::widget::button::Status::Hovered => iced::widget::button::Style {
                background: Some(iced::Background::Color(hover_color)),
                border: iced::Border {
                    radius: 8.0.into(),
                    width: 1.0,
                    color: border_color,
                },
                shadow: iced::Shadow {
                    color: iced::Color::from_rgba(0.0, 0.0, 0.0, 0.1),
                    offset: iced::Vector::new(0.0, 2.0),
                    blur_radius: 4.0,
                },
                ..Default::default()
            },
            _ => iced::widget::button::Style {
                background: Some(iced::Background::Color(base_color)),
                border: iced::Border {
                    radius: 8.0.into(),
                    ..Default::default()
                },
                ..Default::default()
            },
        }
    })
    .on_press(Message::OpenPopup(project.clone()))
    .into()
}

fn create_preview<'a>(
    app: &Papyrust,
    preview: Option<Handle>,
    project: &'a Project,
) -> Element<'a, Message> {
    if let Some(handle) = preview {
        Container::new(
            iced::widget::image(handle)
                .width(Length::Fixed(PREVIEW_WIDTH))
                .height(Length::Fixed(PREVIEW_HEIGHT)),
        )
        .width(Length::Fixed(PREVIEW_WIDTH))
        .height(Length::Fixed(PREVIEW_HEIGHT))
        .clip(true)
        .into()
    } else if project.meta.preview.is_some() {
        let dots = match app.animation_state {
            0 => "Loading.  ",
            1 => "Loading.. ",
            2 => "Loading...",
            _ => "Loading   ",
        };

        Container::new(text(dots).style(|_theme: &_| iced::widget::text::Style {
            color: Some(iced::Color::from_rgba(1.0, 1.0, 1.0, 0.6)),
            ..Default::default()
        }))
        .width(Length::Fixed(PREVIEW_WIDTH))
        .height(Length::Fixed(PREVIEW_HEIGHT))
        .align_x(Horizontal::Center)
        .align_y(Vertical::Center)
        .style(|_theme| iced::widget::container::Style {
            background: Some(iced::Background::Color(iced::Color::from_rgba(
                0.5, 0.5, 0.5, 0.1,
            ))),
            border: iced::Border {
                radius: 4.0.into(),
                ..Default::default()
            },
            ..Default::default()
        })
        .into()
    } else {
        Container::new(
            text("No preview").style(|_theme: &_| iced::widget::text::Style {
                color: Some(iced::Color::from_rgba(1.0, 1.0, 1.0, 0.6)),
                ..Default::default()
            }),
        )
        .width(Length::Fixed(PREVIEW_WIDTH))
        .height(Length::Fixed(PREVIEW_HEIGHT))
        .align_x(Horizontal::Center)
        .align_y(Vertical::Center)
        .style(|_theme| iced::widget::container::Style {
            background: Some(iced::Background::Color(iced::Color::from_rgba(
                0.5, 0.5, 0.5, 0.1,
            ))),
            border: iced::Border {
                radius: 4.0.into(),
                ..Default::default()
            },
            ..Default::default()
        })
        .into()
    }
}
</file>

<file path="src/bin/daemon/media/image.rs">
use anyhow::{Result, anyhow};
use image as img_crate;
use crate::gl_bindings as gl;
use crate::media::{MediaHandler, shader::ShaderHandler};
use crate::utils::{vertex_shader, default_shader, compile_shader};

pub struct ImageHandler {
    texture: u32,
    width: u32,
    height: u32,
    shader_program: u32,
}

impl ImageHandler {
    pub fn new(path: &str, shader_path: Option<&str>) -> Result<Self> {
        tracing::info!(
            event = "image_create",
            path = %path,
            shader = shader_path.unwrap_or("default"),
            "Creating image handler"
        );

        let texture = Self::load_texture(path)?;
        let img = img_crate::open(path)
            .map_err(|e| anyhow!("Failed to open image {}: {}", path, e))?;
        let (width, height) = (img.width(), img.height());

        let shader_program = if let Some(shader_path) = shader_path {
            ShaderHandler::create_media_shader(shader_path)?
        } else {
            Self::create_default_shader()?
        };

        tracing::debug!(
            event = "image_loaded",
            width,
            height,
            texture,
            "Image loaded successfully"
        );

        Ok(Self {
            texture,
            width,
            height,
            shader_program,
        })
    }

    pub fn get_shader_program(&self) -> u32 {
        self.shader_program
    }

    fn load_texture(path: &str) -> Result<u32> {
        tracing::info!(event = "texture_load", path = %path, "Loading texture");

        let img = img_crate::open(path)
            .map_err(|e| anyhow!("Failed to load image {}: {}", path, e))?;
        let rgba = img.to_rgba8();
        let (width, height) = (img.width(), img.height());

        tracing::debug!(event = "image_info", width, height, "Image decoded");

        let mut texture = 0;
        unsafe {
            gl::GenTextures(1, &mut texture);
            gl::BindTexture(gl::TEXTURE_2D, texture);

            gl::PixelStorei(gl::UNPACK_ALIGNMENT, 4);

            gl::TexParameteri(gl::TEXTURE_2D, gl::TEXTURE_WRAP_S, gl::CLAMP_TO_EDGE as i32);
            gl::TexParameteri(gl::TEXTURE_2D, gl::TEXTURE_WRAP_T, gl::CLAMP_TO_EDGE as i32);

            gl::TexParameteri(
                gl::TEXTURE_2D,
                gl::TEXTURE_MIN_FILTER,
                gl::LINEAR_MIPMAP_LINEAR as i32,
            );
            gl::TexParameteri(gl::TEXTURE_2D, gl::TEXTURE_MAG_FILTER, gl::LINEAR as i32);

            let mut max_anisotropy = 0.0f32;
            gl::GetFloatv(0x84FE, &mut max_anisotropy);
            if max_anisotropy > 1.0 {
                let anisotropy = max_anisotropy.min(16.0);
                gl::TexParameterf(gl::TEXTURE_2D, 0x84FE, anisotropy);
                tracing::debug!(
                    event = "anisotropic_filtering",
                    anisotropy,
                    "Applied anisotropic filtering"
                );
            }

            gl::TexImage2D(
                gl::TEXTURE_2D,
                0,
                gl::RGBA as i32,
                width as i32,
                height as i32,
                0,
                gl::RGBA,
                gl::UNSIGNED_BYTE,
                rgba.as_ptr() as *const _,
            );

            gl::GenerateMipmap(gl::TEXTURE_2D);

            tracing::debug!(
                event = "texture_created",
                width,
                height,
                texture,
                "High-quality texture created with mipmaps"
            );
        }

        Ok(texture)
    }

    fn create_default_shader() -> Result<u32> {
        let vert_source = vertex_shader();
        let frag_source = default_shader();
        compile_shader(vert_source, frag_source)
    }
}

impl MediaHandler for ImageHandler {
    fn get_texture(&self) -> Option<u32> {
        Some(self.texture)
    }

    fn get_dimensions(&self) -> (u32, u32) {
        (self.width, self.height)
    }

    fn update(&mut self) -> Result<bool> {
        Ok(false) // Images don't need updates
    }

    fn has_new_frame(&self) -> bool {
        false // Images don't have frames
    }
}

impl Drop for ImageHandler {
    fn drop(&mut self) {
        unsafe {
            gl::DeleteTextures(1, &self.texture);
            gl::DeleteProgram(self.shader_program);
        }
    }
}
</file>

<file path="src/bin/daemon/media/video.rs">
use anyhow::{Result, anyhow};
use ffmpeg_next as ffmpeg;
use std::path::Path;
use crate::gl_bindings as gl;
use crate::media::{MediaHandler, shader::ShaderHandler};
use crate::utils::{vertex_shader, default_shader, compile_shader};

pub struct VideoHandler {
    decoder: ffmpeg::decoder::Video,
    scaler: Option<ffmpeg::software::scaling::Context>,
    texture: u32,
    width: u32,
    height: u32,
    input_ctx: ffmpeg::format::context::Input,
    stream_index: usize,
    video_path: String,
    last_frame_updated: bool,
    time_base: f64,
    playback_start_time: f64,
    forced_fps: Option<f64>,
    current_frame: Option<ffmpeg::frame::Video>,
    next_frame: Option<ffmpeg::frame::Video>,
    current_frame_pts: Option<i64>,
    next_frame_pts: Option<i64>,
    reached_eof: bool,
    video_fps: f64,
    video_duration: f64,
    loop_count: u64,
    first_pts: Option<i64>,
    frame_count: u64,
    shader_program: u32,
}

impl VideoHandler {
    pub fn new(path: &str, shader_path: Option<&str>, forced_fps: Option<f64>) -> Result<Self> {
        let fps_msg = if let Some(fps) = forced_fps {
            format!("forced FPS: {:.1}", fps)
        } else {
            "original timing".to_string()
        };
        tracing::info!(
            event = "video_create",
            path = %path,
            %fps_msg,
            shader = shader_path.unwrap_or("default"),
            "Creating video handler"
        );

        ffmpeg::init().map_err(|e| anyhow!("Failed to initialize FFmpeg: {}", e))?;
        let input_ctx = ffmpeg::format::input(&Path::new(path))
            .map_err(|e| anyhow!("Failed to open video file {}: {}", path, e))?;

        let stream = input_ctx
            .streams()
            .best(ffmpeg::media::Type::Video)
            .ok_or_else(|| anyhow!("No video stream found in {}", path))?;
        let stream_index = stream.index();

        let context_decoder = ffmpeg::codec::context::Context::from_parameters(stream.parameters())
            .map_err(|e| anyhow!("Failed to create codec context: {}", e))?;
        let decoder = context_decoder
            .decoder()
            .video()
            .map_err(|e| anyhow!("Failed to create video decoder: {}", e))?;

        let width = decoder.width();
        let height = decoder.height();

        let time_base = {
            let tb = stream.time_base();
            tb.0 as f64 / tb.1 as f64
        };
        let video_duration = {
            let duration = stream.duration();
            if duration != ffmpeg::ffi::AV_NOPTS_VALUE {
                duration as f64 * time_base
            } else {
                let format_duration = input_ctx.duration();
                if format_duration != ffmpeg::ffi::AV_NOPTS_VALUE {
                    format_duration as f64 / ffmpeg::ffi::AV_TIME_BASE as f64
                } else {
                    0.0
                }
            }
        };

        let video_fps = Self::detect_fps(&stream, time_base);

        tracing::info!(
            event = "video_info",
            width,
            height,
            fps = video_fps,
            forced_fps,
            duration = video_duration,
            time_base,
            "Video stream initialized"
        );

        let scaler = if decoder.format() != ffmpeg::format::Pixel::RGBA {
            Some(
                ffmpeg::software::scaling::Context::get(
                    decoder.format(),
                    width,
                    height,
                    ffmpeg::format::Pixel::RGBA,
                    width,
                    height,
                    ffmpeg::software::scaling::flag::Flags::LANCZOS,
                )
                .map_err(|e| anyhow!("Failed to create scaler: {}", e))?,
            )
        } else {
            None
        };

        let texture = Self::create_texture(width, height)?;

        let shader_program = if let Some(shader_path) = shader_path {
            ShaderHandler::create_media_shader(shader_path)?
        } else {
            Self::create_default_shader()?
        };

        Ok(Self {
            decoder,
            scaler,
            texture,
            width,
            height,
            input_ctx,
            stream_index,
            video_path: path.to_string(),
            last_frame_updated: false,
            time_base,
            playback_start_time: crate::utils::get_time_millis() as f64 / 1000.0,
            forced_fps,
            current_frame: None,
            next_frame: None,
            current_frame_pts: None,
            next_frame_pts: None,
            reached_eof: false,
            video_fps,
            video_duration,
            loop_count: 0,
            first_pts: None,
            frame_count: 0,
            shader_program,
        })
    }

    pub fn get_shader_program(&self) -> u32 {
        self.shader_program
    }

    fn detect_fps(stream: &ffmpeg::format::stream::Stream, time_base: f64) -> f64 {
        let rate = stream.rate();
        let avg_rate = stream.avg_frame_rate();

        let fps_from_rate = if rate.1 > 0 {
            rate.0 as f64 / rate.1 as f64
        } else {
            0.0
        };

        let fps_from_avg = if avg_rate.1 > 0 {
            avg_rate.0 as f64 / avg_rate.1 as f64
        } else {
            0.0
        };

        let detected_fps = if (1.0..=120.0).contains(&fps_from_rate) {
            fps_from_rate
        } else if (1.0..=120.0).contains(&fps_from_avg) {
            fps_from_avg
        } else if time_base > 0.0 {
            let tb_fps = 1.0 / time_base;
            if (1.0..=120.0).contains(&tb_fps) {
                tb_fps
            } else {
                25.0
            }
        } else {
            25.0
        };

        tracing::debug!(
            event = "fps_detection",
            rate_fps = fps_from_rate,
            avg_fps = fps_from_avg,
            time_base_fps = if time_base > 0.0 { 1.0 / time_base } else { 0.0 },
            detected_fps,
            "FPS detection results"
        );

        detected_fps
    }

    fn create_texture(width: u32, height: u32) -> Result<u32> {
        let mut texture = 0;
        unsafe {
            gl::GenTextures(1, &mut texture);
            gl::BindTexture(gl::TEXTURE_2D, texture);
            gl::PixelStorei(gl::UNPACK_ALIGNMENT, 1);

            gl::TexParameteri(gl::TEXTURE_2D, gl::TEXTURE_WRAP_S, gl::CLAMP_TO_EDGE as i32);
            gl::TexParameteri(gl::TEXTURE_2D, gl::TEXTURE_WRAP_T, gl::CLAMP_TO_EDGE as i32);
            gl::TexParameteri(gl::TEXTURE_2D, gl::TEXTURE_MIN_FILTER, gl::LINEAR as i32);
            gl::TexParameteri(gl::TEXTURE_2D, gl::TEXTURE_MAG_FILTER, gl::LINEAR as i32);

            gl::TexImage2D(
                gl::TEXTURE_2D,
                0,
                gl::RGBA as i32,
                width as i32,
                height as i32,
                0,
                gl::RGBA,
                gl::UNSIGNED_BYTE,
                std::ptr::null(),
            );
        }
        Ok(texture)
    }

    fn create_default_shader() -> Result<u32> {
        let vert_source = vertex_shader();
        let frag_source = default_shader();
        compile_shader(vert_source, frag_source)
    }

    fn update_frame(&mut self) -> Result<bool> {
        self.last_frame_updated = false;
        let current_time = crate::utils::get_time_millis() as f64 / 1000.0;
        let playback_time = current_time - self.playback_start_time;

        if self.next_frame.is_none() {
            self.decode_next_frame()?;
        }

        let should_display_next = if let Some(forced_fps) = self.forced_fps {
            let frame_duration = 1.0 / forced_fps;
            let expected_frame_time = self.frame_count as f64 * frame_duration;
            playback_time >= expected_frame_time
        } else {
            if let Some(next_pts) = self.next_frame_pts {
                let frame_time = self.pts_to_time(next_pts);
                playback_time >= frame_time
            } else {
                let frame_duration = 1.0 / self.video_fps;
                let expected_frame_time = self.frame_count as f64 * frame_duration;
                playback_time >= expected_frame_time
            }
        };

        if should_display_next && self.next_frame.is_some() {
            self.current_frame = self.next_frame.take();
            self.current_frame_pts = self.next_frame_pts.take();

            if let Some(ref frame) = self.current_frame {
                self.upload_frame(frame);
                self.last_frame_updated = true;
                self.frame_count += 1;

                self.decode_next_frame()?;
            }
        }

        Ok(self.last_frame_updated)
    }

    fn pts_to_time(&self, pts: i64) -> f64 {
        let adjusted_pts = if let Some(first) = self.first_pts {
            pts - first
        } else {
            pts
        };
        adjusted_pts as f64 * self.time_base
    }

    fn decode_next_frame(&mut self) -> Result<()> {
        if self.next_frame.is_some() {
            return Ok(());
        }

        if !self.decode_frame_to_buffer()? {
            self.loop_count += 1;
            tracing::debug!(
                event = "video_loop",
                loop_count = self.loop_count,
                frame_count = self.frame_count,
                "Video restarted for loop"
            );

            let expected_loop_duration = if let Some(forced_fps) = self.forced_fps {
                self.frame_count as f64 / forced_fps
            } else if self.video_duration > 0.0 {
                self.video_duration
            } else {
                self.frame_count as f64 / self.video_fps
            };

            let current_time = crate::utils::get_time_millis() as f64 / 1000.0;
            self.playback_start_time =
                current_time - (self.loop_count as f64 * expected_loop_duration);

            self.frame_count = 0;
            self.first_pts = None;

            self.restart_video()?;
            self.decode_frame_to_buffer()?;

            tracing::debug!(
                event = "video_loop_timing",
                expected_duration = expected_loop_duration,
                new_start_time = self.playback_start_time,
                "Adjusted timing for seamless loop"
            );
        }
        Ok(())
    }

    fn decode_frame_to_buffer(&mut self) -> Result<bool> {
        if self.reached_eof {
            return Ok(false);
        }

        for (stream, packet) in self.input_ctx.packets() {
            if stream.index() != self.stream_index {
                continue;
            }

            match self.decoder.send_packet(&packet) {
                Ok(_) => {
                    let mut decoded = ffmpeg::frame::Video::empty();
                    while self.decoder.receive_frame(&mut decoded).is_ok() {
                        let pts = decoded.pts();

                        if let Some(pts_val) = pts {
                            if self.first_pts.is_none() {
                                self.first_pts = Some(pts_val);
                                tracing::debug!(
                                    event = "video_first_pts",
                                    pts = pts_val,
                                    time = self.pts_to_time(pts_val),
                                    "First frame PTS recorded"
                                );
                            }
                        }

                        let rgba_frame = self.convert_frame(decoded)?;
                        self.next_frame = Some(rgba_frame);
                        self.next_frame_pts = pts;
                        return Ok(true);
                    }
                }
                Err(ffmpeg::Error::Eof) => {
                    self.reached_eof = true;
                    return Ok(false);
                }
                Err(_) => {
                    continue;
                }
            }
        }

        self.reached_eof = true;
        Ok(false)
    }

    fn convert_frame(&mut self, frame: ffmpeg::frame::Video) -> Result<ffmpeg::frame::Video> {
        if frame.format() != ffmpeg::format::Pixel::RGBA {
            if let Some(ref mut scaler) = self.scaler {
                let mut rgba_frame = ffmpeg::frame::Video::empty();
                scaler
                    .run(&frame, &mut rgba_frame)
                    .map_err(|e| anyhow!("Scaling failed: {}", e))?;
                rgba_frame.set_pts(frame.pts());
                Ok(rgba_frame)
            } else {
                Ok(frame)
            }
        } else {
            Ok(frame)
        }
    }

    fn upload_frame(&self, frame: &ffmpeg::frame::Video) {
        unsafe {
            gl::BindTexture(gl::TEXTURE_2D, self.texture);
            gl::PixelStorei(gl::UNPACK_ALIGNMENT, 1);
            gl::TexSubImage2D(
                gl::TEXTURE_2D,
                0,
                0,
                0,
                frame.width() as i32,
                frame.height() as i32,
                gl::RGBA,
                gl::UNSIGNED_BYTE,
                frame.data(0).as_ptr() as *const _,
            );
        }
    }

    fn restart_video(&mut self) -> Result<()> {
        self.current_frame = None;
        self.next_frame = None;
        self.current_frame_pts = None;
        self.next_frame_pts = None;
        self.reached_eof = false;

        self.input_ctx = ffmpeg::format::input(&Path::new(&self.video_path))
            .map_err(|e| anyhow!("Failed to re-open video {}: {}", self.video_path, e))?;

        let stream = self
            .input_ctx
            .streams()
            .best(ffmpeg::media::Type::Video)
            .ok_or_else(|| anyhow!("No video stream on restart"))?;

        self.stream_index = stream.index();

        let context_decoder =
            ffmpeg::codec::context::Context::from_parameters(stream.parameters())?;
        self.decoder = context_decoder.decoder().video()?;

        Ok(())
    }
}

impl MediaHandler for VideoHandler {
    fn get_texture(&self) -> Option<u32> {
        Some(self.texture)
    }

    fn get_dimensions(&self) -> (u32, u32) {
        (self.width, self.height)
    }

    fn update(&mut self) -> Result<bool> {
        self.update_frame()
    }

    fn has_new_frame(&self) -> bool {
        self.last_frame_updated
    }
}

impl Drop for VideoHandler {
    fn drop(&mut self) {
        unsafe {
            gl::DeleteTextures(1, &self.texture);
            gl::DeleteProgram(self.shader_program);
        }
    }
}
</file>

<file path="src/bin/daemon/utils.rs">
use crate::gl_bindings as gl;
use anyhow::{Result, anyhow};
use std::ffi::{CStr, CString};
use std::thread;
use std::time::Duration;
use std::time::{SystemTime, UNIX_EPOCH};

pub fn get_time_millis() -> u64 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_millis() as u64
}

pub fn sleep_millis(millis: u64) {
    if millis > 0 {
        thread::sleep(Duration::from_millis(millis));
    }
}

pub fn check_gl_error(context: &str) {
    unsafe {
        let error = gl::GetError();
        if error != gl::NO_ERROR {
            let error_str = match error {
                gl::INVALID_ENUM => "GL_INVALID_ENUM",
                gl::INVALID_VALUE => "GL_INVALID_VALUE",
                gl::INVALID_OPERATION => "GL_INVALID_OPERATION",
                gl::OUT_OF_MEMORY => "GL_OUT_OF_MEMORY",
                _ => "Unknown error",
            };
            tracing::error!(
                event = "gl_error",
                context = %context,
                error = %error_str,
                error_code = error,
                "OpenGL error detected"
            );
        }
    }
}

pub fn default_shader() -> &'static str {
    r#"
#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D u_media;
uniform vec2 u_resolution;
uniform float u_time;

varying vec2 texCoords;

void main() {
    vec2 uv = texCoords;
    
    // High-quality scaling with subtle animation
    float scale = 1.0 + 0.005 * sin(u_time * 1.5);
    vec2 center = vec2(0.5);
    uv = (uv - center) * scale + center;
    
    // Ensure UV coordinates stay within bounds
    uv = clamp(uv, 0.0, 1.0);
    
    // Sample texture with high precision
    vec4 color = texture2D(u_media, uv);
    
    // Preserve original color fidelity
    gl_FragColor = color;
}
"#
}

pub fn vertex_shader() -> &'static str {
    r#"
#version 100
attribute highp vec2 datIn;
attribute highp vec2 texIn;
varying highp vec2 texCoords;

void main() {
    texCoords = texIn;
    gl_Position = vec4(datIn, 0.0, 1.0);
}
"#
}

pub fn compile_shader(vert_source: &str, frag_source: &str) -> Result<u32> {
    unsafe {
        let program = gl::CreateProgram();
        check_gl_error("CreateProgram");

        let vert_shader = gl::CreateShader(gl::VERTEX_SHADER);
        check_gl_error("CreateShader vertex");
        let vert_c_str = CString::new(vert_source)?;
        gl::ShaderSource(vert_shader, 1, &vert_c_str.as_ptr(), std::ptr::null());
        gl::CompileShader(vert_shader);
        check_gl_error("CompileShader vertex");
        check_shader_compile(vert_shader, "vertex")?;

        let frag_shader = gl::CreateShader(gl::FRAGMENT_SHADER);
        check_gl_error("CreateShader fragment");
        let frag_c_str = CString::new(frag_source)?;
        gl::ShaderSource(frag_shader, 1, &frag_c_str.as_ptr(), std::ptr::null());
        gl::CompileShader(frag_shader);
        check_gl_error("CompileShader fragment");
        check_shader_compile(frag_shader, "fragment")?;

        gl::AttachShader(program, vert_shader);
        gl::AttachShader(program, frag_shader);
        check_gl_error("AttachShader");
        gl::LinkProgram(program);
        check_gl_error("LinkProgram");
        check_program_link(program)?;

        gl::DeleteShader(vert_shader);
        gl::DeleteShader(frag_shader);
        check_gl_error("DeleteShader");

        tracing::debug!(
            event = "shader_compiled",
            program,
            "Successfully compiled and linked shader program"
        );

        Ok(program)
    }
}

fn check_shader_compile(shader: u32, shader_type: &str) -> Result<()> {
    unsafe {
        let mut status = 0;
        gl::GetShaderiv(shader, gl::COMPILE_STATUS, &mut status);
        if status == gl::FALSE as i32 {
            let mut log_length = 0;
            gl::GetShaderiv(shader, gl::INFO_LOG_LENGTH, &mut log_length);
            let mut log = vec![0u8; log_length as usize];
            gl::GetShaderInfoLog(
                shader,
                log_length,
                std::ptr::null_mut(),
                log.as_mut_ptr() as *mut i8,
            );
            let log_str = CStr::from_ptr(log.as_ptr() as *const i8).to_string_lossy();
            return Err(anyhow!(
                "{} shader compilation failed: {}",
                shader_type,
                log_str
            ));
        }
    }
    Ok(())
}

fn check_program_link(program: u32) -> Result<()> {
    unsafe {
        let mut status = 0;
        gl::GetProgramiv(program, gl::LINK_STATUS, &mut status);
        if status == gl::FALSE as i32 {
            let mut log_length = 0;
            gl::GetProgramiv(program, gl::INFO_LOG_LENGTH, &mut log_length);
            let mut log = vec![0u8; log_length as usize];
            gl::GetProgramInfoLog(
                program,
                log_length,
                std::ptr::null_mut(),
                log.as_mut_ptr() as *mut i8,
            );
            let log_str = CStr::from_ptr(log.as_ptr() as *const i8).to_string_lossy();
            return Err(anyhow!("Program linking failed: {}", log_str));
        }
    }
    Ok(())
}

pub fn prepare_shader_source(raw_shader: &str) -> String {
    let mut version_directive: Option<&str> = None;
    let mut body_lines = Vec::new();

    for line in raw_shader.lines() {
        let trimmed = line.trim_start();
        if version_directive.is_none() && trimmed.starts_with("#version") {
            version_directive = Some(line);
        } else {
            body_lines.push(line);
        }
    }

    body_lines.retain(|l| {
        let t = l.trim_start();
        !(t.starts_with("precision ") && t.ends_with("float;"))
    });

    let mut frag_source = String::new();
    if let Some(v) = version_directive {
        frag_source.push_str(v);
        frag_source.push('\n');
    }

    frag_source.push_str(
        r#"
        #ifdef GL_ES
          #ifdef GL_FRAGMENT_PRECISION_HIGH
            precision highp float;
          #else
            precision mediump float;
          #endif
        #endif
        "#,
    );

    frag_source.push_str(&body_lines.join("\n"));
    frag_source
}
</file>

<file path=".gitignore">
/target
repomix-output.xml
flamegraph.svg
perf.data
perf.data.old
stacks.folded
</file>

<file path="src/bin/cli.rs">
use anyhow::Result;
use clap::{Parser, Subcommand};
use serde_json::json;
use std::io::{BufRead, BufReader, Write};
use std::os::unix::net::UnixStream;
use tracing_subscriber::{EnvFilter, fmt};

#[derive(Parser)]
#[command(name = "papyrust")]
#[command(about = "A small cli for papyrust-daemon")]
struct Args {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    Image {
        path: String,
        #[arg(long)]
        shader: Option<String>,
        #[arg(long, action = clap::ArgAction::Append)]
        monitor: Vec<String>,
    },
    Video {
        path: String,
        #[arg(long)]
        shader: Option<String>,
        #[arg(long, action = clap::ArgAction::Append)]
        monitor: Vec<String>,
        #[arg(long)]
        mute: bool,
    },
    Shader {
        path: String,
        #[arg(long, action = clap::ArgAction::Append)]
        monitor: Vec<String>,
    },
}

fn main() -> Result<()> {
    let _ = fmt()
        .with_env_filter(
            EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new("off")),
        )
        .with_target(true)
        .compact()
        .try_init();
    let args = Args::parse();

    let mut stream = UnixStream::connect("/tmp/papyrust-daemon.sock")?;

    let command = match args.command {
        Commands::Image {
            path,
            shader,
            monitor,
        } => {
            let monitors = if monitor.is_empty() { None } else { Some(monitor) };
            json!({
                "SetImage": {
                    "path": path,
                    "shader": shader,
                    "monitors": monitors
                }
            })
        }
        Commands::Video {
            path,
            shader,
            monitor,
            mute,
        } => {
            let monitors = if monitor.is_empty() { None } else { Some(monitor) };
            json!({
                "SetVideo": {
                    "path": path,
                    "shader": shader,
                    "monitors": monitors,
                    "mute": mute
                }
            })
        }
        Commands::Shader { path, monitor } => {
            let monitors = if monitor.is_empty() { None } else { Some(monitor) };
            json!({
                "SetShader": {
                    "path": path,
                    "monitors": monitors
                }
            })
        }
    };

    writeln!(stream, "{}", command)?;
    stream.flush()?;

    let mut reader = BufReader::new(stream);
    let mut response = String::new();
    reader.read_line(&mut response)?;

    println!("{}", response.trim());
    Ok(())
}
</file>

<file path="src/ui/ipc.rs">
use anyhow::Result;
use serde_json::json;
use std::io::{BufRead, BufReader, Write};
use std::os::unix::net::UnixStream;

use tracing::info;
const SOCKET_PATH: &str = "/tmp/papyrust-daemon.sock";

pub fn set_image(monitor: String, path: String, shader: Option<String>) -> Result<()> {
    let cmd = json!({
        "SetImage": {
            "path": path,
            "shader": shader,
            "monitor": monitor
        }
    });
    send_command(cmd)
}

pub fn set_video(monitor: String, path: String, shader: Option<String>) -> Result<()> {
    let cmd = json!({
        "SetVideo": {
            "path": path,
            "shader": shader,
            // "monitor": monitor
        }
    });
    send_command(cmd)
}

pub fn set_shader(monitor: String, path: String) -> Result<()> {
    let cmd = json!({
        "SetShader": {
            "path": path,
            "monitor": monitor
        }
    });
    send_command(cmd)
}


fn send_command(cmd: serde_json::Value) -> Result<()> {
    tracing::debug!(event = "ui_send_cmd", cmd = %cmd, "Sending IPC command");

    let mut stream = UnixStream::connect(SOCKET_PATH)?;
    writeln!(stream, "{}", cmd)?;
    stream.flush()?;

    let mut reader = BufReader::new(stream);
    let mut response = String::new();
    reader.read_line(&mut response)?;

    info!("{}", response.trim());
    tracing::debug!(event = "ui_recv_reply", reply = %response.trim(), "Received IPC reply");
    Ok(())
}
</file>

<file path="src/ui/mod.rs">
pub mod components;
pub mod ipc;
pub mod loader;
pub mod pages;
pub mod state;
pub mod view;
</file>

<file path="src/bin/daemon/ipc.rs">
use crate::media::MediaType;
use anyhow::{Result, anyhow};
use serde::{Deserialize, Serialize};
use std::io::{BufRead, BufReader, Write};
use std::os::unix::net::{UnixListener, UnixStream};
use std::sync::mpsc::Sender;
use std::thread;

#[derive(Debug, Serialize, Deserialize)]
pub enum IpcCommand {
    SetImage {
        path: String,
        shader: Option<String>,
        monitors: Option<Vec<String>>,
    },
    SetVideo {
        path: String,
        shader: Option<String>,
        monitors: Option<Vec<String>>,
        #[serde(default)]
        mute: bool,
    },
    SetShader {
        path: String,
        monitors: Option<Vec<String>>,
    },
}

#[derive(Debug, Serialize, Deserialize)]
pub enum IpcResponse {
    Success,
    Error { message: String },
    Status { current_media: String },
}

#[derive(Debug, Clone)]
pub struct MediaChange {
    pub media_type: MediaType,
    pub monitors: Option<Vec<String>>,
    pub mute: bool,
}

pub fn start_server(tx: Sender<MediaChange>) -> Result<()> {
    let socket_path = "/tmp/papyrust-daemon.sock";
    let _ = std::fs::remove_file(socket_path);

    let listener =
        UnixListener::bind(socket_path).map_err(|e| anyhow!("Failed to bind IPC socket: {}", e))?;

    tracing::info!(
        event = "ipc_listen",
        path = socket_path,
        "IPC server listening"
    );
    for stream in listener.incoming() {
        match stream {
            Ok(stream) => {
                let tx_clone = tx.clone();
                thread::spawn(move || {
                    if let Err(e) = handle_client(stream, tx_clone) {
                        tracing::warn!(event = "ipc_client_error", error = %e, "Client handling error");
                    }
                });
            }
            Err(e) => {
                tracing::warn!(event = "ipc_accept_error", error = %e, "IPC accept failed");
            }
        }
    }

    Ok(())
}

fn handle_client(stream: UnixStream, tx: Sender<MediaChange>) -> Result<()> {
    let peer = stream.peer_addr().ok();
    tracing::debug!(event = "ipc_client_begin", ?peer, "Client connected");

    let mut reader = BufReader::new(&stream);
    let mut writer = stream.try_clone()?;
    let mut line = String::new();

    while reader.read_line(&mut line)? > 0 {
        let trimmed = line.trim();
        let command: IpcCommand =
            serde_json::from_str(trimmed).map_err(|e| anyhow!("Invalid JSON command: {}", e))?;

        match &command {
            IpcCommand::SetImage { monitors, path, .. } => {
                let target_desc = match monitors {
                    None => "all monitors".to_string(),
                    Some(mons) => format!("monitors: {}", mons.join(", ")),
                };
                tracing::info!(event = "ipc_command", cmd = "SetImage", target = %target_desc, path = %path, "Applying image");
            }
            IpcCommand::SetVideo {
                monitors,
                path,
                mute,
                ..
            } => {
                let target_desc = match monitors {
                    None => "all monitors".to_string(),
                    Some(mons) => format!("monitors: {}", mons.join(", ")),
                };
                tracing::info!(event = "ipc_command", cmd = "SetVideo", target = %target_desc, path = %path, mute = *mute, "Applying video");
            }
            IpcCommand::SetShader { monitors, path } => {
                let target_desc = match monitors {
                    None => "all monitors".to_string(),
                    Some(mons) => format!("monitors: {}", mons.join(", ")),
                };
                tracing::info!(event = "ipc_command", cmd = "SetShader", target = %target_desc, path = %path, "Applying shader");
            }
        }

        let response = match command {
            IpcCommand::SetImage {
                path,
                shader,
                monitors,
            } => {
                let media_change = MediaChange {
                    media_type: MediaType::Image { path, shader },
                    monitors,
                    mute: false,
                };
                match tx.send(media_change) {
                    Ok(_) => IpcResponse::Success,
                    Err(e) => IpcResponse::Error {
                        message: e.to_string(),
                    },
                }
            }
            IpcCommand::SetVideo {
                path,
                shader,
                monitors,
                mute,
            } => {
                let media_change = MediaChange {
                    media_type: MediaType::Video { path, shader },
                    monitors,
                    mute,
                };
                match tx.send(media_change) {
                    Ok(_) => IpcResponse::Success,
                    Err(e) => IpcResponse::Error {
                        message: e.to_string(),
                    },
                }
            }
            IpcCommand::SetShader { path, monitors } => {
                let media_change = MediaChange {
                    media_type: MediaType::Shader(path),
                    monitors,
                    mute: false,
                };
                match tx.send(media_change) {
                    Ok(_) => IpcResponse::Success,
                    Err(e) => IpcResponse::Error {
                        message: e.to_string(),
                    },
                }
            }
        };

        let response_json = serde_json::to_string(&response)?;
        writeln!(writer, "{}", response_json)?;
        writer.flush()?;

        tracing::debug!(event = "ipc_reply", response = %response_json, "Sent reply to client");
        line.clear();
    }

    tracing::debug!(event = "ipc_client_end", "Client disconnected");
    Ok(())
}
</file>

<file path="src/bin/daemon/wayland/mod.rs">
use crate::utils;
use crate::ipc::MediaChange;
use crate::media::MediaType;
use anyhow::{Result, anyhow};
use std::process::Child;
use std::sync::mpsc::Receiver;
use wayland_client::Connection;

pub mod traits;
pub mod types;
pub mod protocol;
pub mod rendering;
pub mod audio;
pub mod monitors;

use protocol::ProtocolState;
use monitors::MonitorManager;
use audio::fifo::FifoReader;
use types::WaylandConfig;
use traits::WaylandSurface as WaylandSurfaceTrait;

pub struct WaylandManager {
    protocol_state: ProtocolState,
    monitor_manager: MonitorManager,
    config: WaylandConfig,
}

impl WaylandManager {
    pub fn new(config: WaylandConfig) -> Self {
        Self {
            protocol_state: ProtocolState::new(),
            monitor_manager: MonitorManager::new(),
            config,
        }
    }

    pub fn initialize(&mut self, conn: &Connection) -> Result<()> {
        let mut event_queue = conn.new_event_queue();
        let qh = event_queue.handle();
        let mut app_state = protocol::events::AppState::new();
        
        let _registry = conn.display().get_registry(&qh, ());
        event_queue.roundtrip(&mut app_state)?;

        if let Some(ref om) = app_state.output_manager {
            for (id, info) in &app_state.outputs {
                om.get_xdg_output(&info.output, &qh, *id);
            }
        }
        event_queue.roundtrip(&mut app_state)?;

        let compositor = app_state
            .compositor
            .as_ref()
            .ok_or_else(|| anyhow!("Compositor not available"))?;
        let layer_shell = app_state
            .layer_shell
            .as_ref()
            .ok_or_else(|| anyhow!("Layer shell not available"))?;

        for output_info in app_state.outputs.values() {
            if let Some(_name) = &output_info.name {
                self.monitor_manager.create_surface(
                    output_info,
                    compositor,
                    layer_shell,
                    self.config.layer_name.as_deref(),
                    MediaType::Shader("default".to_string()),
                    conn,
                    &qh,
                    self.config.fps,
                )?;
                self.protocol_state.total_surfaces += 1;
            }
        }

        event_queue.roundtrip(&mut app_state)?;
        while app_state.configured_count < app_state.total_surfaces {
            tracing::debug!(
                event = "waiting_layer_config",
                configured = app_state.configured_count,
                total = app_state.total_surfaces,
                "Awaiting layer surface configuration"
            );
            event_queue.blocking_dispatch(&mut app_state)?;
        }
        event_queue.roundtrip(&mut app_state)?;

        // Apply initial configurations
        for surface in self.monitor_manager.surfaces_mut() {
            if let Some((width, height)) = app_state.layer_surface_configs.get(&surface.surface_id.0) {
                tracing::info!(
                    event = "surface_configured",
                    output = %surface.output_name,
                    width, height,
                    "Applying initial layer surface config"
                );
                WaylandSurfaceTrait::resize(surface, *width, *height)?;
            }
        }

        Ok(())
    }
}

pub fn init(
    media_type: MediaType,
    fps: u16,
    layer_name: Option<&str>,
    fifo_path: Option<&str>,
    ipc_receiver: Receiver<MediaChange>,
    mute: bool,
    sharpening: f32,
) -> Result<()> {
    tracing::info!(
        event = "wayland_init",
        fps,
        layer = layer_name,
        fifo = fifo_path,
        mute,
        sharpening,
        "Initializing Wayland stack with lossless scaling"
    );

    let config = WaylandConfig {
        fps,
        layer_name: layer_name.map(String::from),
        fifo_path: fifo_path.map(String::from),
        mute,
        sharpening,
    };

    let conn = Connection::connect_to_env()?;
    let mut wayland_manager = WaylandManager::new(config);
    wayland_manager.initialize(&conn)?;

    let mut fifo_reader = fifo_path.map(FifoReader::new).transpose()?;
    let mut has_video = matches!(media_type, MediaType::Video { .. });
    
    wayland_manager.monitor_manager.set_swap_intervals(has_video, fps)?;

    tracing::info!(
        event = "render_loop_start",
        monitors = wayland_manager.monitor_manager.len(),
        "Starting render loop"
    );

    let mut last_audio_path: Option<String> = None;
    let mut last_audio_child: Option<Child> = None;
    let mut frame_count = 0u64;
    let mut last_fps_check = utils::get_time_millis();

    let target_frame_time = if fps > 0 { 1000 / fps as u64 } else { 16 };

    loop {
        let frame_start = utils::get_time_millis();

        // Handle IPC messages
        if let Ok(media_change) = ipc_receiver.try_recv() {
            let new_has_video = matches!(media_change.media_type, MediaType::Video { .. });
            if has_video != new_has_video {
                has_video = new_has_video;
                wayland_manager.monitor_manager.set_swap_intervals(has_video, fps)?;
                tracing::info!(
                    event = "swap_interval_reconfigured",
                    has_video,
                    "Reconfigured swap intervals due to media type change"
                );
            }

            // Handle audio for video files
            if let MediaType::Video { path, .. } = &media_change.media_type {
                let effective_mute = mute || media_change.mute;

                if effective_mute || last_audio_path.as_deref() != Some(path.as_str()) {
                    if let Some(mut child) = last_audio_child.take() {
                        let _ = child.kill();
                        let _ = child.wait();
                        tracing::debug!(event = "audio_player_stopped", "Stopped ffplay");
                    }
                }

                if !effective_mute && last_audio_path.as_deref() != Some(path.as_str()) {
                    let audio_path = path.clone();
                    match std::process::Command::new("ffplay")
                        .args(&[
                            "-nodisp",
                            "-autoexit", 
                            "-hide_banner",
                            "-loglevel",
                            "error",
                            "-loop",
                            "0",
                            &audio_path,
                        ])
                        .spawn()
                    {
                        Ok(child) => {
                            last_audio_child = Some(child);
                            last_audio_path = Some(path.clone());
                            tracing::info!(event = "audio_player_started", path = %audio_path, "Started ffplay for audio");
                        }
                        Err(e) => {
                            tracing::warn!(event = "audio_player_fail", error = %e, path = %audio_path, "Failed to start ffplay");
                        }
                    }
                } else if effective_mute {
                    last_audio_path = None;
                }
            } else {
                if let Some(mut child) = last_audio_child.take() {
                    let _ = child.kill();
                    let _ = child.wait();
                    tracing::debug!(
                        event = "audio_player_stopped",
                        "Stopped ffplay due to non-video media"
                    );
                }
                last_audio_path = None;
            }

            // Update media - convert Option<Vec<String>> to Option<&[String]>
            let target_monitors = media_change.monitors.as_deref();
            wayland_manager.monitor_manager.update_media(
                target_monitors,
                media_change.media_type,
                fps,
            )?;
        }

        // Render all surfaces
        let any_video_updated = wayland_manager.monitor_manager.render_all(fifo_reader.as_mut())?;

        frame_count += 1;

        // Frame timing
        if has_video {
            if fps == 0 {
                let elapsed = utils::get_time_millis() - frame_start;
                let target_frame_time = if any_video_updated { 16 } else { 33 };
                if elapsed < target_frame_time {
                    utils::sleep_millis(target_frame_time - elapsed);
                }
            } else {
                let elapsed = utils::get_time_millis() - frame_start;
                if elapsed < target_frame_time {
                    utils::sleep_millis(target_frame_time - elapsed);
                }
            }
        } else {
            let elapsed = utils::get_time_millis() - frame_start;
            let adaptive_frame_time = if any_video_updated {
                target_frame_time
            } else {
                target_frame_time * 2
            };
            if elapsed < adaptive_frame_time {
                utils::sleep_millis(adaptive_frame_time - elapsed);
            }
        }

        // FPS tracking
        if frame_count % 300 == 0 {
            let now = utils::get_time_millis();
            let _fps_actual = 300000 / (now - last_fps_check + 1);
            last_fps_check = now;
        }
    }
}
</file>

<file path="src/bin/daemon/main.rs">
use anyhow::Result;
use clap::{Parser, ValueEnum};
use std::{process, sync::mpsc, thread};

use tracing_log::LogTracer;
use tracing_subscriber::{EnvFilter, fmt};

mod ipc;
mod media;
mod utils;
mod wayland; 

mod gl_bindings {
    include!(concat!(env!("OUT_DIR"), "/gl_bindings.rs"));
}

#[derive(ValueEnum, Clone, Debug)]
enum Layer {
    Bottom,
    Top,
    Overlay,
    Background,
}

impl std::fmt::Display for Layer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let s = match self {
            Layer::Bottom => "bottom",
            Layer::Top => "top",
            Layer::Overlay => "overlay",
            Layer::Background => "background",
        };
        write!(f, "{}", s)
    }
}

#[derive(ValueEnum, Clone, Debug)]
enum ScalingMode {
    FSR,
    Lanczos,
    Mitchell,
    Bicubic,
    None,
}

#[derive(Parser, Debug)]
#[command(
    name = "papyrust-daemon",
    version = "0.1.0",
    about = "A Wayland wallpaper daemon with OpenGL ES shader support"
)]
struct Args {
    #[arg(short = 'F', long)]
    fork: bool,

    #[arg(short, long, default_value = "60")]
    fps: u16,

    #[arg(short, long)]
    layer: Option<Layer>,

    #[arg(short = 'M', long)]
    fifo: Option<String>,

    #[arg(long, alias = "no-audio")]
    mute: bool,

    #[arg(short = 's', long, default_value = "fsr")]
    scaling: ScalingMode,

    #[arg(long, default_value = "0.3")]
    sharpening: f32,
}

fn main() -> Result<()> {
    let _ = LogTracer::init();
    let filter = EnvFilter::try_from_default_env()
        .unwrap_or_else(|_| EnvFilter::new("papyrust=info,wayland_client=warn"));
    let _ = fmt()
        .with_env_filter(filter)
        .with_target(true)
        .compact()
        .try_init();

    let args = Args::parse();

    tracing::info!(
        event = "daemon_start",
        fork = args.fork,
        fps = args.fps,
        layer = args.layer.as_ref().map(|l| l.to_string()),
        fifo = args.fifo.as_deref(),
        mute = args.mute,
        scaling = ?args.scaling,
        sharpening = args.sharpening,
        "Starting Papyrust daemon with lossless scaling"
    );

    if args.fork {
        unsafe {
            let pid = libc::fork();
            if pid > 0 {
                process::exit(0);
            }
            if pid == 0 {
                libc::close(0);
                libc::close(1);
                libc::close(2);
                tracing::debug!(
                    event = "daemon_forked",
                    "Detached from controlling terminal"
                );
            }
        }
    }

    let (tx, rx) = mpsc::channel();

    let ipc_tx = tx.clone();
    thread::spawn(move || {
        if let Err(e) = ipc::start_server(ipc_tx) {
            tracing::error!(event = "ipc_server_error", error = %e, "IPC server error");
        }
    });

    let init_media = media::MediaType::Shader("default".to_string());

    wayland::init(
        init_media,
        args.fps,
        args.layer.as_ref().map(|l| l.to_string()).as_deref(),
        args.fifo.as_deref(),
        rx,
        args.mute,
        args.sharpening,
    )?;

    tracing::info!(event = "daemon_exit", "Papyrust daemon exited");
    Ok(())
}
</file>

<file path="src/ui/view.rs">
use iced::{
    alignment::{Horizontal, Vertical},
    widget::{image::Handle, Column, Container, Stack},
    Element, Length, Padding,
};
use iced_aw::Wrap;

use crate::{ui::loader::project::Project, Message, Papyrust};

use super::{components::lib_popup, components::panel, pages::discover, pages::library, state};

pub fn build(app: &Papyrust) -> Element<Message> {
    let content = match app.current_page {
        state::Page::Discover => discover::build(app),
        state::Page::Library => library::build(app),
    };

    let main = Column::new()
        .push(content)
        .width(Length::Fill)
        .height(Length::Fill);

    let panel = Container::new(panel::build(app))
        .width(Length::Fill)
        .height(Length::Fill)
        .padding(Padding {
            top: 0.0,
            right: 20.0,
            bottom: 0.0,
            left: 0.0,
        })
        .align_x(Horizontal::Center)
        .align_y(Vertical::Bottom);

    let main_content = Column::new().push(main).push(
        Container::new(panel)
            .width(Length::Fill)
            .height(Length::Fixed(80.0)),
    );

    if let Some(ref project) = app.popup_state {
        Stack::new()
            .push(main_content)
            .push(lib_popup::build(app, project))
            .into()
    } else {
        main_content.into()
    }
}

pub fn create_grid<'a>(
    app: &'a Papyrust,
    projects: &'a [Project],
    preview: &'a [Option<Handle>],
) -> Element<'a, Message> {
    let mut items = Vec::new();

    for (idx, project) in projects.iter().enumerate() {
        let handle = preview.get(idx).and_then(Clone::clone);
        items.push(library::render_item(app, project, handle));
    }

    Container::new(Wrap::with_elements(items).spacing(8.0).line_spacing(8.0))
        .width(Length::Fill)
        .padding(8)
        .into()
}
</file>

<file path="src/ui/state.rs">
use iced::{widget::image::Handle, Task};

use tracing::error;
use crate::{Message, Papyrust};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Page {
    Discover,
    Library,
}

impl Default for Page {
    fn default() -> Self {
        Page::Library
    }
}

pub fn update(app: &mut Papyrust, message: Message) -> Task<Message> {
    match message {
        Message::SwitchPage(page) => {
            app.current_page = page;
            if page == Page::Library {
                return app.library.next().unwrap_or_else(Task::none);
            }
            Task::none()
        }
        Message::PreviewDecoded(idx, w, h, pixels) => {
            let handle = Handle::from_rgba(w, h, pixels);
            app.library.preview[idx] = Some(handle);
            app.library.next().unwrap_or_else(Task::none)
        }
        Message::PreviewError(_idx) => app.library.next().unwrap_or_else(Task::none),
        Message::Tick => {
            app.tick();
            Task::none()
        }
        Message::OpenPopup(project) => {
            app.popup_state = Some(project.clone());

            if let Some(file_name) = &project.meta.file {
                let video_path = format!("{}/{}", project.path, file_name);
                if app.should_load(&video_path) {
                    return Papyrust::load_video_async(video_path);
                }
            }
            Task::none()
        }
        Message::ClosePopup => {
            for video in app.videos.values_mut() {
                video.set_paused(true);
            }
            app.popup_state = None;
            Task::none()
        }
        Message::ApplyProject(project) => {
            if let Some(popup) = &app.popup_state {
                if popup.path == project.path {
                    app.popup_state = Some(project.clone());
                }
            } else {
                app.popup_state = Some(project.clone());
            }

            if let Some(file_name) = &project.meta.file {
                let video_path = format!("{}/{}", project.path, file_name);
                crate::ui::ipc::set_video("DP-2".to_string(), video_path, None).unwrap_or_else(
                    |e| {
                        error!("Failed to set video: {}", e);
                    },
                );
            }
            Task::none()
        }
        Message::LoadVideo(path) => {
            app.load_video(&path);
            Task::none()
        }
        Message::VideoLoaded(path) => {
            app.load_video(&path);
            Task::none()
        }
        Message::VideoError(path, error) => {
            error!("Failed to load video {}: {}", path, error);
            Task::none()
        }
        Message::DoNothing => Task::none(),
    }
}
</file>

<file path="Cargo.toml">
[package]
name = "papyrust"
version = "0.1.0"
edition = "2024"

[dependencies]
derive = "1.0.0"
fast_image_resize = { version = "5.1.4", features = ["image"] }
futures = "0.3.31"
iced = { version = "0.13.1", features = ["advanced", "image", "tokio"] }
iced_aw = { version = "0.12.2", features = ["wrap"] }
iced_video_player = { git = "https://github.com/jazzfool/iced_video_player" }
image = "0.25.6"
serde = { version = "1.0.219", features = ["derive"] }
serde_json = "1.0.140"
shellexpand = "3.1.1"
tokio = { version = "1.45.1", features = ["fs"] }
url = "2.5.4"

clap = { version = "4.4", features = ["derive"] }
wayland-client = "0.31"
wayland-protocols = { version = "0.31", features = ["client", "unstable"] }
wayland-protocols-wlr = { version = "0.2", features = ["client"] }
wayland-egl = "0.32"
khronos-egl = { version = "6.0", features = ["static"] }
gl = "0.14"
libc = "0.2"
anyhow = "1.0"
ffmpeg-next = "7.1.0"

wgpu = "0.20"
bytemuck = { version = "1.16", features = ["derive"] }
pollster = "0.3"

tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }
tracing-log = "0.2"

[build-dependencies]
gl_generator = "0.14"

[profile.release]
debug = true

[profile.dev]
debug = true
opt-level = 0
overflow-checks = true

[lints.rust]
unsafe_op_in_unsafe_fn = "allow"

[[bin]]
name = "papyrust-daemon"
path = "src/bin/daemon/main.rs"

[[bin]]
name = "papyrust-cli"
path = "src/bin/cli.rs"

[[bin]]
name = "papyrust"
path = "src/main.rs"
</file>

<file path="src/main.rs">
use std::collections::HashMap;

use iced::{Element, Font, Settings, Subscription, Task};
use iced_video_player::Video;
use ui::state;

mod ui;

use ui::pages::library::Library;
use ui::{state::Page, view};

use crate::ui::loader::project::Project;

pub struct Papyrust {
    pub current_page: Page,
    pub library: Library,
    pub animation_state: usize,
    pub popup_state: Option<Project>,
    pub videos: HashMap<String, Video>,
}

#[derive(Debug, Clone)]
pub enum Message {
    SwitchPage(Page),
    PreviewDecoded(usize, u32, u32, Vec<u8>),
    PreviewError(usize),
    OpenPopup(Project),
    ClosePopup,
    ApplyProject(Project),
    Tick,
    LoadVideo(String),
    VideoLoaded(String),
    VideoError(String, String),
    DoNothing,
}

const _FIRA_BYTES: &[u8] = include_bytes!("../fonts/FiraCodeNerdFontMono-Regular.ttf");
const _UNIFONT_BYTES: &[u8] = include_bytes!("../fonts/unifont.ttf");

const _FIRA: Font = Font::with_name("FiraCode Nerd Font Mono Reg");
const _UNIFONT: Font = Font::with_name("Unifont");

impl Papyrust {
    fn new() -> (Self, Task<Message>) {
        let mut library = Library::new();
        let first = library.next().unwrap_or_else(Task::none);
        (
            Papyrust {
                current_page: Page::default(),
                library,
                animation_state: 0,
                popup_state: None,
                videos: HashMap::new(),
            },
            first,
        )
    }

    pub fn load_video(&mut self, path: &str) -> Option<&Video> {
        if !self.videos.contains_key(path) {
            if let Ok(url) = url::Url::parse(&format!("file://{}", path)) {
                if let Ok(video) = Video::new(&url) {
                    self.videos.insert(path.to_string(), video);
                }
            }
        }
        self.videos.get(path)
    }

    pub fn load_video_async(path: String) -> Task<Message> {
        Task::perform(
            async move {
                match url::Url::parse(&format!("file://{}", path)) {
                    Ok(url) => match tokio::task::spawn_blocking(move || Video::new(&url)).await {
                        Ok(Ok(_)) => Message::VideoLoaded(path),
                        Ok(Err(e)) => Message::VideoError(path, e.to_string()),
                        Err(e) => Message::VideoError(path, format!("Task error: {}", e)),
                    },
                    Err(e) => Message::VideoError(path, format!("Invalid URL: {}", e)),
                }
            },
            |msg| msg,
        )
    }

    pub fn peek_video(&self, path: &str) -> Option<&Video> {
        self.videos.get(path)
    }

    pub fn should_load(&self, path: &str) -> bool {
        !self.videos.contains_key(path)
    }

    pub fn tick(&mut self) {
        self.animation_state = (self.animation_state + 1) % 4;
    }

    fn update(&mut self, message: Message) -> Task<Message> {
        state::update(self, message)
    }

    fn view(&self) -> Element<Message> {
        view::build(self)
    }

    fn subscription(&self) -> Subscription<Message> {
        iced::time::every(std::time::Duration::from_millis(300)).map(|_| Message::Tick)
    }
}


fn main() -> iced::Result {
    let _ = tracing_log::LogTracer::init();
    let filter = tracing_subscriber::EnvFilter::try_from_default_env()
        .unwrap_or_else(|_| tracing_subscriber::EnvFilter::new("papyrust=info"));
    let _ = tracing_subscriber::fmt()
        .with_env_filter(filter)
        .with_target(true)
        .compact()
        .try_init();

    iced::application("Papyrust", Papyrust::update, Papyrust::view)
        .settings(Settings {
            default_font: Font::MONOSPACE,
            ..Default::default()
        })
        .subscription(Papyrust::subscription)
        .theme(|_| iced::theme::Theme::GruvboxDark)
        .run_with(Papyrust::new)
}
</file>

</files>
