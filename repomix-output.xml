This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
src/
  library/
    loader.rs
    mod.rs
    project.rs
  ui/
    discover.rs
    library.rs
    mod.rs
    panel.rs
    state.rs
    view.rs
  main.rs
.gitignore
Cargo.toml
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/ui/discover.rs">
use iced::Element;

use crate::{Message, Papyrust};

pub fn build(_app: &Papyrust) -> Element<Message> {
    iced::widget::text("Discover").into()
}
</file>

<file path=".gitignore">
/target
</file>

<file path="src/library/loader.rs">
use std::{fs, path::PathBuf};

use super::project::{Project, ProjectMeta};

const WALLPAPER_ENGINE_ID: &str = "431960";
const WORKSHOP_PATHS: [&str; 4] = [
    "~/.steam/steam/steamapps/workshop",
    "~/.local/share/Steam/steamapps/workshop",
    "~/.var/app/com.valvesoftware.Steam/.local/share/Steam/steamapps/workshop",
    "~/snap/steam/common/.local/share/Steam/steamapps/workshop",
];

fn resolve_paths() -> Vec<PathBuf> {
    WORKSHOP_PATHS
        .iter()
        .map(|p| shellexpand::tilde(p).to_string())
        .map(PathBuf::from)
        .filter(|p| p.exists())
        .map(|p| p.join("content").join(WALLPAPER_ENGINE_ID))
        .filter(|p| p.exists())
        .collect()
}

/// Lazily yields one parsed `Project` (or error) at a time.
pub struct Loader {
    project_paths: Vec<PathBuf>,
    current: usize,
}

impl Loader {
    /// Collects all candidate project dirs but does *not* parse them yet.
    pub fn new() -> Self {
        let mut paths = Vec::new();

        for base in resolve_paths() {
            if let Ok(entries) = fs::read_dir(base) {
                for entry in entries.flatten() {
                    let dir = entry.path();
                    if dir.is_dir() && dir.join("project.json").exists() {
                        paths.push(dir);
                    }
                }
            }
        }

        Loader {
            project_paths: paths,
            current: 0,
        }
    }

    /// Returns the next Project (or parse error), or `None` if exhausted.
    pub fn next(&mut self) -> Option<Result<Project, String>> {
        if self.current >= self.project_paths.len() {
            None
        } else {
            let dir = self.project_paths[self.current].clone();
            self.current += 1;
            let json_path = dir.join("project.json");
            Some(parse(&json_path, &dir))
        }
    }

    /// How many projects remain to load.
    pub fn remaining(&self) -> usize {
        self.project_paths.len().saturating_sub(self.current)
    }
}

fn parse(json_path: &PathBuf, project_dir: &PathBuf) -> Result<Project, String> {
    let content = fs::read_to_string(json_path)
        .map_err(|e| format!("Failed to read {}: {}", json_path.display(), e))?;

    let meta: ProjectMeta = serde_json::from_str(&content)
        .map_err(|e| format!("JSON parse error in {}: {}", json_path.display(), e))?;

    Ok(Project {
        meta,
        path: project_dir.to_string_lossy().to_string(),
    })
}
</file>

<file path="src/library/mod.rs">
pub mod loader;
pub mod project;
</file>

<file path="src/library/project.rs">
use serde::Deserialize;

#[derive(Deserialize, Debug, Clone)]
#[serde(rename_all = "lowercase")]
pub enum ProjectType {
    #[serde(alias = "Web")]
    Web,
    #[serde(alias = "Video")]
    Video,
    #[serde(alias = "Application")]
    Application,
    #[serde(alias = "Scene")]
    Scene,
}

#[derive(Deserialize, Debug, Clone)]
pub struct ProjectMeta {
    pub title: Option<String>,
    pub description: Option<String>,
    pub tags: Option<Vec<String>>,
    #[serde(rename = "type")]
    pub file_type: Option<ProjectType>,
    pub preview: Option<String>,
    pub file: Option<String>,
}

#[derive(Clone, Debug)]
pub struct Project {
    pub meta: ProjectMeta,
    pub path: String,
}
</file>

<file path="src/ui/mod.rs">
pub mod discover;
pub mod library;
pub mod panel;
pub mod state;
pub mod view;
</file>

<file path="src/ui/panel.rs">
use iced::{
    widget::{text, Button, Container, Row},
    Alignment, Element, Padding,
};

use crate::Message;

use super::state::Page;

pub fn build(_app: &crate::Papyrust) -> Element<Message> {
    let library = Button::new(text("Library"))
        .on_press(Message::SwitchPage(Page::Library))
        .padding(Padding::from([8, 16]));

    let discover = Button::new(text("Discover"))
        .on_press(Message::SwitchPage(Page::Discover))
        .padding(Padding::from([8, 16]));

    let content = Row::new()
        .push(library)
        .push(discover)
        .spacing(15)
        .align_y(Alignment::Center);

    Container::new(content)
        .padding(Padding::from([10, 20]))
        .into()
}
</file>

<file path="src/ui/view.rs">
use iced::{
    alignment::{Horizontal, Vertical},
    widget::{Column, Container},
    Element, Length, Padding,
};

use crate::{Message, Papyrust};

use super::{discover, library, panel, state};

pub fn build(app: &Papyrust) -> Element<Message> {
    let content = match app.current_page {
        state::Page::Discover => discover::build(app),
        state::Page::Library => library::build(app),
    };

    let main_content = Column::new()
        .push(content)
        .width(Length::Fill)
        .height(Length::Fill);

    let panel = Container::new(panel::build(app))
        .width(Length::Fill)
        .height(Length::Fill)
        .padding(Padding {
            top: 0.0,
            right: 20.0,
            bottom: 0.0,
            left: 0.0,
        })
        .align_x(Horizontal::Center)
        .align_y(Vertical::Bottom);

    Column::new()
        .push(main_content)
        .push(
            Container::new(panel)
                .width(Length::Fill)
                .height(Length::Fixed(80.0)),
        )
        .into()
}
</file>

<file path="src/ui/state.rs">
use crate::{Message, Papyrust};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Page {
    Discover,
    Library,
}

impl Default for Page {
    fn default() -> Self {
        Page::Library
    }
}

pub fn update(app: &mut Papyrust, message: Message) {
    match message {
        Message::SwitchPage(page) => {
            app.current_page = page;
        }
        // Message::Error(err) => {
        // eprintln!("Error: {}", err);
        // }
        _ => {}
    }
}
</file>

<file path="src/ui/library.rs">
use iced::widget::image::Handle;
use iced::{
    widget::{column, container, scrollable, text},
    Element, Length,
};

use crate::library::{loader::Loader, project::Project};
use crate::{Message, Papyrust};

pub struct Library {
    loader: Loader,
    pub projects: Vec<Project>,
    pub preview_handles: Vec<Option<Handle>>,
}

impl Library {
    /// Start with *no* projects; loader has the full list.
    pub fn new() -> Self {
        Self {
            loader: Loader::new(),
            projects: Vec::new(),
            preview_handles: Vec::new(),
        }
    }

    /// Attempt to load exactly one more project (if any remain).
    pub fn load_next(&mut self) {
        if let Some(result) = self.loader.next() {
            match result {
                Ok(project) => {
                    self.projects.push(project);
                    self.preview_handles.push(None);
                }
                Err(e) => eprintln!("Project parse error: {}", e),
            }
        }
    }

    /// True if there are still more projects to pull from the loader.
    pub fn has_more(&self) -> bool {
        self.loader.remaining() > 0
    }
}

pub fn build(app: &Papyrust) -> Element<Message> {
    let lib = &app.library;
    // reuse your existing grid‐creation logic:
    let grid = super::view::create_grid(&lib.projects, &lib.preview_handles);

    container(scrollable(column![text("Library").size(30), grid]))
        .padding(20)
        .width(Length::Fill)
        .height(Length::Fill)
        .into()
}
</file>

<file path="Cargo.toml">
[package]
name = "papyrust"
version = "0.1.0"
edition = "2024"

[dependencies]
derive = "1.0.0"
iced = { version = "0.13.1", features = ["image"] }
iced_video_player = { git = "https://github.com/jazzfool/iced_video_player" }
serde = { version = "1.0.219", features = ["derive"] }
serde_json = "1.0.140"
shellexpand = "3.1.1"
tokio = "1.45.1"
url = "2.5.4"
</file>

<file path="src/main.rs">
use iced::widget::image::Handle;
use iced::{Element, Task};
use std::fs;

mod library;
mod ui;

use library::loader::Loader; // for type only; UI holds the real one
use ui::library::Library;
use ui::{state::Page, view};

pub struct Papyrust {
    pub current_page: Page,
    pub library: Library,
}

#[derive(Debug, Clone)]
pub enum Message {
    SwitchPage(Page),
    NextProject,
    /// (index, optional_bytes)
    PreviewLoaded(usize, Option<Vec<u8>>),
}

impl Papyrust {
    /// We start with no projects loaded; fire off a single NextProject.
    fn new() -> (Self, Task<Message>) {
        let library = Library::new();
        let init = Task::perform(async {}, |_| Message::NextProject);

        (
            Papyrust {
                current_page: Page::default(),
                library,
            },
            init,
        )
    }

    fn update(&mut self, message: Message) -> Task<Message> {
        match message {
            Message::SwitchPage(page) => {
                self.current_page = page;
                Task::none()
            }

            Message::NextProject => {
                // load exactly one project…
                self.library.load_next();
                let idx = self.library.projects.len() - 1;
                let mut tasks = Vec::new();

                // …then spawn its preview‐load if it has one
                if let Some(preview_name) = self.library.projects[idx].meta.preview.as_ref() {
                    let path = format!("{}/{}", self.library.projects[idx].path, preview_name);
                    tasks.push(Task::perform(
                        async move { (idx, fs::read(path).ok()) },
                        Message::PreviewLoaded,
                    ));
                }

                // …and if there's more to go, queue up another NextProject
                if self.library.has_more() {
                    tasks.push(Task::perform(async {}, |_| Message::NextProject));
                }

                Task::batch(tasks)
            }

            Message::PreviewLoaded(index, maybe_bytes) => {
                if let Some(bytes) = maybe_bytes {
                    let handle = Handle::from_bytes(bytes);
                    if index < self.library.preview_handles.len() {
                        self.library.preview_handles[index] = Some(handle);
                    }
                }
                Task::none()
            }
        }
    }

    fn view(&self) -> Element<Message> {
        view(self)
    }
}

fn main() -> iced::Result {
    iced::application("Papyrust", Papyrust::update, Papyrust::view)
        .theme(|_| iced::theme::Theme::GruvboxDark)
        .run_with(Papyrust::new)
}
</file>

</files>
