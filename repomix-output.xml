This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
shaders/
  plasma.frag
  rainbow.frag
src/
  bin/
    cli.rs
  daemon/
    ipc.rs
    main.rs
    media.rs
    paper.rs
    utils.rs
  library/
    loader.rs
    mod.rs
    project.rs
  ui/
    discover.rs
    library.rs
    mod.rs
    panel.rs
    popup.rs
    state.rs
    view.rs
  main.rs
.gitignore
build.rs
Cargo.toml
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="shaders/plasma.frag">
#ifdef GL_ES
precision mediump float;
#endif

uniform float time;
uniform vec2 resolution;
varying vec2 texCoords;

void main() {
    vec2 uv = texCoords;
    vec2 p = (uv - 0.5) * vec2(resolution.x/resolution.y, 1.0) * 2.0;

    float v1 = sin(p.x * 3.0 + time);
    float v2 = sin((p.x * cos(time*0.7) + p.y * sin(time*0.3)) * 4.0);
    float v3 = sin(length(p) * 5.0 - time * 1.5);

    float v = (v1 + v2 + v3) / 3.0;

    vec3 col = vec3(
        0.5 + 0.5 * sin(3.0 + v * 3.0),
        0.5 + 0.5 * sin(1.0 + v * 3.0),
        0.5 + 0.5 * sin(5.0 + v * 3.0)
    );

    gl_FragColor = vec4(col, 1.0);
}
</file>

<file path="shaders/rainbow.frag">
#version 100
precision mediump float;

uniform float time;
uniform vec2 resolution;

void main() {
    vec2 uv = gl_FragCoord.xy / resolution;

    float wave = 0.5 + 0.5 * sin(uv.x * 10.0 + time);

    gl_FragColor = vec4(uv.x, uv.y, wave, 1.0);
}
</file>

<file path="src/daemon/utils.rs">
use std::thread;
use std::time::Duration;
use std::time::{SystemTime, UNIX_EPOCH};

pub fn get_time_millis() -> u64 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_millis() as u64
}

pub fn sleep_millis(millis: u64) {
    if millis > 0 {
        thread::sleep(Duration::from_millis(millis));
    }
}
</file>

<file path="src/ui/discover.rs">
use iced::Element;

use crate::{Message, Papyrust};

pub fn build(_app: &Papyrust) -> Element<Message> {
    iced::widget::text("Discover").into()
}
</file>

<file path="build.rs">
use gl_generator::{Api, Fallbacks, Profile, Registry};
use std::env;
use std::fs::File;
use std::path::Path;

fn main() {
    let dest = env::var("OUT_DIR").unwrap();
    let mut file = File::create(&Path::new(&dest).join("gl_bindings.rs")).unwrap();

    Registry::new(Api::Gles2, (3, 0), Profile::Core, Fallbacks::All, [])
        .write_bindings(gl_generator::GlobalGenerator, &mut file)
        .unwrap();
}
</file>

<file path="src/bin/cli.rs">
use anyhow::Result;
use clap::{Parser, Subcommand};
use serde_json;
use std::io::{BufRead, BufReader, Write};
use std::os::unix::net::UnixStream;

#[derive(Parser)]
#[command(name = "papyrust")]
#[command(about = "A small cli for papyrust-daemon")]
struct Args {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    Image {
        path: String,
        #[arg(long)]
        shader: Option<String>,
        #[arg(long)]
        monitor: Option<String>,
    },
    Video {
        path: String,
        #[arg(long)]
        shader: Option<String>,
        #[arg(long)]
        monitor: Option<String>,
    },
    Shader {
        path: String,
        #[arg(long)]
        monitor: Option<String>,
    },
    Status,
}

fn main() -> Result<()> {
    let args = Args::parse();

    let mut stream = UnixStream::connect("/tmp/papyrust-daemon.sock")?;

    let command = match args.command {
        Commands::Image {
            path,
            shader,
            monitor,
        } => {
            serde_json::json!({
                "SetImage": {
                    "path": path,
                    "shader": shader,
                    "monitor": monitor
                }
            })
        }
        Commands::Video {
            path,
            shader,
            monitor,
        } => {
            serde_json::json!({
                "SetVideo": {
                    "path": path,
                    "shader": shader,
                    "monitor": monitor
                }
            })
        }
        Commands::Shader { path, monitor } => {
            serde_json::json!({
                "SetShader": {
                    "path": path,
                    "monitor": monitor
                }
            })
        }
        Commands::Status => {
            serde_json::json!("GetStatus")
        }
    };

    writeln!(stream, "{}", command)?;
    stream.flush()?;

    let mut reader = BufReader::new(stream);
    let mut response = String::new();
    reader.read_line(&mut response)?;

    println!("{}", response.trim());

    Ok(())
}
</file>

<file path="src/daemon/ipc.rs">
use anyhow::{anyhow, Result};
use serde::{Deserialize, Serialize};
use std::io::{BufRead, BufReader, Write};
use std::os::unix::net::{UnixListener, UnixStream};
use std::sync::mpsc::Sender;
use std::thread;

use crate::media::MediaType;

#[derive(Debug, Serialize, Deserialize)]
pub enum IpcCommand {
    SetImage {
        path: String,
        shader: Option<String>,
        monitor: Option<String>,
    },
    SetVideo {
        path: String,
        shader: Option<String>,
        monitor: Option<String>,
    },
    SetShader {
        path: String,
        monitor: Option<String>,
    },
    GetStatus,
}

#[derive(Debug, Serialize, Deserialize)]
pub enum IpcResponse {
    Success,
    Error { message: String },
    Status { current_media: String },
}

#[derive(Debug, Clone)]
pub struct MediaChange {
    pub media_type: MediaType,
    pub monitor: Option<String>,
}

pub fn start_server(tx: Sender<MediaChange>) -> Result<()> {
    let socket_path = "/tmp/papyrust-daemon.sock";

    let _ = std::fs::remove_file(socket_path);

    let listener =
        UnixListener::bind(socket_path).map_err(|e| anyhow!("Failed to bind IPC socket: {}", e))?;

    println!("IPC server listening on {}", socket_path);

    for stream in listener.incoming() {
        match stream {
            Ok(stream) => {
                let tx_clone = tx.clone();
                thread::spawn(move || {
                    if let Err(e) = handle_client(stream, tx_clone) {
                        eprintln!("Client error: {}", e);
                    }
                });
            }
            Err(e) => {
                eprintln!("Connection failed: {}", e);
            }
        }
    }

    Ok(())
}

fn handle_client(stream: UnixStream, tx: Sender<MediaChange>) -> Result<()> {
    let mut reader = BufReader::new(&stream);
    let mut writer = stream.try_clone()?;
    let mut line = String::new();

    while reader.read_line(&mut line)? > 0 {
        let command: IpcCommand = serde_json::from_str(&line.trim())
            .map_err(|e| anyhow!("Invalid JSON command: {}", e))?;

        let response = match command {
            IpcCommand::SetImage {
                path,
                shader,
                monitor,
            } => {
                let media_change = MediaChange {
                    media_type: MediaType::Image { path, shader },
                    monitor,
                };
                match tx.send(media_change) {
                    Ok(_) => IpcResponse::Success,
                    Err(e) => IpcResponse::Error {
                        message: e.to_string(),
                    },
                }
            }
            IpcCommand::SetVideo {
                path,
                shader,
                monitor,
            } => {
                let media_change = MediaChange {
                    media_type: MediaType::Video { path, shader },
                    monitor,
                };
                match tx.send(media_change) {
                    Ok(_) => IpcResponse::Success,
                    Err(e) => IpcResponse::Error {
                        message: e.to_string(),
                    },
                }
            }
            IpcCommand::SetShader { path, monitor } => {
                let media_change = MediaChange {
                    media_type: MediaType::Shader(path),
                    monitor,
                };
                match tx.send(media_change) {
                    Ok(_) => IpcResponse::Success,
                    Err(e) => IpcResponse::Error {
                        message: e.to_string(),
                    },
                }
            }
            IpcCommand::GetStatus => IpcResponse::Status {
                current_media: "Unknown".to_string(),
            },
        };

        let response_json = serde_json::to_string(&response)?;
        writeln!(writer, "{}", response_json)?;
        writer.flush()?;

        line.clear();
    }

    Ok(())
}
</file>

<file path="src/daemon/media.rs">
use anyhow::{anyhow, Result};
use ffmpeg_next as ffmpeg;
use std::fs::File;
use std::io::Read;
use std::path::Path;

use crate::gl_bindings as gl;

#[derive(Debug, Clone, PartialEq)]
pub enum MediaType {
    Shader(String),
    Image {
        path: String,
        shader: Option<String>,
    },
    Video {
        path: String,
        shader: Option<String>,
    },
}

pub struct ImageLoader;

impl ImageLoader {
    pub fn load_texture(path: &str) -> Result<u32> {
        eprintln!("Loading image: {}", path);

        let img = image::open(path).map_err(|e| anyhow!("Failed to load image {}: {}", path, e))?;

        let rgba = img.to_rgba8();
        let (width, height) = (img.width(), img.height());

        eprintln!("Image loaded: {}x{}", width, height);

        let mut texture = 0;
        unsafe {
            gl::GenTextures(1, &mut texture);
            gl::BindTexture(gl::TEXTURE_2D, texture);

            gl::PixelStorei(gl::UNPACK_ALIGNMENT, 1);

            gl::TexParameteri(gl::TEXTURE_2D, gl::TEXTURE_WRAP_S, gl::CLAMP_TO_EDGE as i32);
            gl::TexParameteri(gl::TEXTURE_2D, gl::TEXTURE_WRAP_T, gl::CLAMP_TO_EDGE as i32);
            gl::TexParameteri(gl::TEXTURE_2D, gl::TEXTURE_MIN_FILTER, gl::LINEAR as i32);
            gl::TexParameteri(gl::TEXTURE_2D, gl::TEXTURE_MAG_FILTER, gl::LINEAR as i32);

            gl::TexImage2D(
                gl::TEXTURE_2D,
                0,
                gl::RGBA as i32,
                width as i32,
                height as i32,
                0,
                gl::RGBA,
                gl::UNSIGNED_BYTE,
                rgba.as_ptr() as *const _,
            );

            eprintln!("Texture created successfully: {}", texture);
        }

        Ok(texture)
    }
}

pub struct VideoDecoder {
    decoder: ffmpeg::decoder::Video,
    scaler: Option<ffmpeg::software::scaling::Context>,
    texture: u32,
    _width: u32,
    _height: u32,
    input_ctx: ffmpeg::format::context::Input,
    stream_index: usize,
    video_path: String,
    eof_reached: bool,
}

impl VideoDecoder {
    pub fn new(path: &str) -> Result<Self> {
        eprintln!("Initializing video decoder for: {}", path);

        ffmpeg::init().map_err(|e| anyhow!("Failed to initialize FFmpeg: {}", e))?;

        let input_ctx = ffmpeg::format::input(&Path::new(path))
            .map_err(|e| anyhow!("Failed to open video file {}: {}", path, e))?;

        let stream = input_ctx
            .streams()
            .best(ffmpeg::media::Type::Video)
            .ok_or_else(|| anyhow!("No video stream found in {}", path))?;

        let stream_index = stream.index();

        let context_decoder = ffmpeg::codec::context::Context::from_parameters(stream.parameters())
            .map_err(|e| anyhow!("Failed to create codec context: {}", e))?;

        let decoder = context_decoder
            .decoder()
            .video()
            .map_err(|e| anyhow!("Failed to create video decoder: {}", e))?;

        let width = decoder.width();
        let height = decoder.height();

        eprintln!("Video info: {}x{}", width, height);

        let scaler = if decoder.format() != ffmpeg::format::Pixel::RGB24 {
            Some(
                ffmpeg::software::scaling::Context::get(
                    decoder.format(),
                    width,
                    height,
                    ffmpeg::format::Pixel::RGB24,
                    width,
                    height,
                    ffmpeg::software::scaling::flag::Flags::BILINEAR,
                )
                .map_err(|e| anyhow!("Failed to create scaler: {}", e))?,
            )
        } else {
            None
        };

        let mut texture = 0;
        unsafe {
            gl::GenTextures(1, &mut texture);
            gl::BindTexture(gl::TEXTURE_2D, texture);

            gl::PixelStorei(gl::UNPACK_ALIGNMENT, 1);

            gl::TexParameteri(gl::TEXTURE_2D, gl::TEXTURE_WRAP_S, gl::CLAMP_TO_EDGE as i32);
            gl::TexParameteri(gl::TEXTURE_2D, gl::TEXTURE_WRAP_T, gl::CLAMP_TO_EDGE as i32);
            gl::TexParameteri(gl::TEXTURE_2D, gl::TEXTURE_MIN_FILTER, gl::LINEAR as i32);
            gl::TexParameteri(gl::TEXTURE_2D, gl::TEXTURE_MAG_FILTER, gl::LINEAR as i32);

            // empty texture
            gl::TexImage2D(
                gl::TEXTURE_2D,
                0,
                gl::RGB as i32,
                width as i32,
                height as i32,
                0,
                gl::RGB,
                gl::UNSIGNED_BYTE,
                std::ptr::null(),
            );
        }

        Ok(Self {
            decoder,
            scaler,
            texture,
            _width: width,
            _height: height,
            input_ctx,
            stream_index,
            video_path: path.to_string(),
            eof_reached: false,
        })
    }

    pub fn update_frame(&mut self) -> Result<bool> {
        let mut frame_updated = false;

        // restart the video
        if self.eof_reached {
            self.restart_video()?;
            self.eof_reached = false;
        }

        for (stream, packet) in self.input_ctx.packets() {
            if stream.index() == self.stream_index {
                match self.decoder.send_packet(&packet) {
                    Ok(_) => {
                        let mut decoded_frame = ffmpeg::frame::Video::empty();

                        while self.decoder.receive_frame(&mut decoded_frame).is_ok() {
                            let rgb_frame = if decoded_frame.format()
                                != ffmpeg::format::Pixel::RGB24
                            {
                                if let Some(ref mut scaler) = self.scaler {
                                    let mut rgb_frame = ffmpeg::frame::Video::empty();
                                    scaler
                                        .run(&decoded_frame, &mut rgb_frame)
                                        .map_err(|e| anyhow!("Scaling failed: {}", e))?;
                                    rgb_frame
                                } else {
                                    let mut new_scaler = ffmpeg::software::scaling::Context::get(
                                        decoded_frame.format(),
                                        decoded_frame.width(),
                                        decoded_frame.height(),
                                        ffmpeg::format::Pixel::RGB24,
                                        decoded_frame.width(),
                                        decoded_frame.height(),
                                        ffmpeg::software::scaling::flag::Flags::BILINEAR,
                                    )
                                    .map_err(|e| anyhow!("Failed to create scaler: {}", e))?;

                                    let mut rgb_frame = ffmpeg::frame::Video::empty();
                                    new_scaler
                                        .run(&decoded_frame, &mut rgb_frame)
                                        .map_err(|e| anyhow!("Scaling failed: {}", e))?;
                                    self.scaler = Some(new_scaler);
                                    rgb_frame
                                }
                            } else {
                                decoded_frame
                            };

                            unsafe {
                                gl::BindTexture(gl::TEXTURE_2D, self.texture);
                                gl::PixelStorei(gl::UNPACK_ALIGNMENT, 1);
                                gl::TexSubImage2D(
                                    gl::TEXTURE_2D,
                                    0,
                                    0,
                                    0,
                                    rgb_frame.width() as i32,
                                    rgb_frame.height() as i32,
                                    gl::RGB,
                                    gl::UNSIGNED_BYTE,
                                    rgb_frame.data(0).as_ptr() as *const _,
                                );
                            }

                            frame_updated = true;
                            return Ok(frame_updated);
                        }
                    }
                    Err(ffmpeg::Error::Eof) => {
                        self.eof_reached = true;
                        break;
                    }
                    Err(_) => {
                        continue;
                    }
                }
            }
        }

        if !frame_updated {
            self.eof_reached = true;
        }

        Ok(frame_updated)
    }

    fn restart_video(&mut self) -> Result<()> {
        if let Err(_) = self.input_ctx.seek(0, 0..i64::MAX) {
            eprintln!("Seeking failed, recreating input context");

            self.input_ctx = ffmpeg::format::input(&Path::new(&self.video_path))
                .map_err(|e| anyhow!("Failed to reopen video file: {}", e))?;

            let stream = self
                .input_ctx
                .streams()
                .best(ffmpeg::media::Type::Video)
                .ok_or_else(|| anyhow!("No video stream found after restart"))?;

            self.stream_index = stream.index();

            let context_decoder =
                ffmpeg::codec::context::Context::from_parameters(stream.parameters())
                    .map_err(|e| anyhow!("Failed to recreate codec context: {}", e))?;

            self.decoder = context_decoder
                .decoder()
                .video()
                .map_err(|e| anyhow!("Failed to recreate video decoder: {}", e))?;
        }

        Ok(())
    }

    pub fn texture(&self) -> u32 {
        self.texture
    }

    pub fn _dimensions(&self) -> (u32, u32) {
        (self._width, self._height)
    }
}

pub fn load_shader(path: &str) -> Result<String> {
    let mut file =
        File::open(path).map_err(|e| anyhow!("Failed to open shader file {}: {}", path, e))?;
    let mut source = String::new();
    file.read_to_string(&mut source)
        .map_err(|e| anyhow!("Failed to read shader file {}: {}", path, e))?;
    Ok(source)
}

pub fn default_shader() -> &'static str {
    r#"
#ifdef GL_ES
precision mediump float;
#endif

uniform sampler2D u_media;
uniform vec2 u_resolution;
uniform float u_time;

varying vec2 texCoords;

void main() {
    // Simple passthrough with optional UV animation
    vec2 uv = texCoords;
    
    // Subtle breathing effect
    float scale = 1.0 + 0.01 * sin(u_time * 2.0);
    uv = (uv - 0.5) * scale + 0.5;
    
    vec4 color = texture2D(u_media, uv);
    gl_FragColor = color;
}
"#
}

pub fn vertex_shader() -> &'static str {
    r#"
#version 100
attribute vec2 datIn;
attribute vec2 texIn;
varying vec2 texCoords;

void main() {
    texCoords = texIn;
    gl_Position = vec4(datIn, 0.0, 1.0);
}
"#
}
</file>

<file path="src/library/mod.rs">
pub mod loader;
pub mod project;
</file>

<file path="src/daemon/main.rs">
use anyhow::Result;
use clap::Parser;
use log::info;
use std::process;
use std::sync::mpsc;
use std::thread;

mod ipc;
mod media;
mod paper;
mod utils;
mod gl_bindings {
    include!(concat!(env!("OUT_DIR"), "/gl_bindings.rs"));
}

#[derive(Parser, Debug)]
#[command(
    name = "papyrust-daemon",
    version = "0.1.0",
    about = "A Wayland wallpaper daemon with OpenGL ES shader support for images, videos, and shaders"
)]
struct Args {
    #[arg(short = 'F', long)]
    fork: bool,

    #[arg(short, long, default_value = "0")]
    fps: u16,

    #[arg(short, long)]
    layer: Option<String>,

    #[arg(short = 'W', long, default_value = "0")]
    width: u16,

    #[arg(short = 'H', long, default_value = "0")]
    height: u16,

    #[arg(short = 'M', long)]
    fifo: Option<String>,
}

fn main() -> Result<()> {
    env_logger::init();

    let args = Args::parse();

    if args.fork {
        unsafe {
            let pid = libc::fork();
            if pid > 0 {
                process::exit(0);
            }
            if pid == 0 {
                libc::close(0);
                libc::close(1);
                libc::close(2);
            }
        }
    }

    let (tx, rx) = mpsc::channel();

    let ipc_tx = tx.clone();
    thread::spawn(move || {
        if let Err(e) = ipc::start_server(ipc_tx) {
            eprintln!("IPC server error: {}", e);
        }
    });

    let init_media = media::MediaType::Shader("default".to_string());

    info!("Starting Papyrust daemon");

    paper::init(
        init_media,
        args.fps,
        args.layer.as_deref(),
        args.width,
        args.height,
        args.fifo.as_deref(),
        rx,
    )?;

    Ok(())
}
</file>

<file path="src/daemon/paper.rs">
use anyhow::{anyhow, Result};
use khronos_egl as egl;
use log::{debug, info};
use std::collections::HashMap;
use std::ffi::{CStr, CString};
use std::os::unix::io::{AsRawFd, RawFd};
use std::sync::mpsc::Receiver;
use wayland_client::protocol::{wl_compositor, wl_output, wl_region, wl_registry, wl_surface};
use wayland_client::{Connection, Dispatch, Proxy, QueueHandle};
use wayland_protocols::xdg::xdg_output::zv1::client::{zxdg_output_manager_v1, zxdg_output_v1};
use wayland_protocols_wlr::layer_shell::v1::client::{zwlr_layer_shell_v1, zwlr_layer_surface_v1};

use crate::gl_bindings as gl;
use crate::ipc::MediaChange;
use crate::media::{
    default_shader, load_shader, vertex_shader, ImageLoader, MediaType, VideoDecoder,
};
use crate::utils;

const N_SAMPLES: usize = 44100 / 25;

#[derive(Debug, Clone)]
struct OutputInfo {
    _id: u32,
    output: wl_output::WlOutput,
    width: i32,
    height: i32,
    name: Option<String>,
}

#[derive(Debug)]
struct StereoSample {
    left: Vec<i16>,
    right: Vec<i16>,
}

impl StereoSample {
    fn new() -> Self {
        Self {
            left: vec![0; N_SAMPLES],
            right: vec![0; N_SAMPLES],
        }
    }
}

struct AppState {
    outputs: HashMap<u32, OutputInfo>,
    compositor: Option<wl_compositor::WlCompositor>,
    layer_shell: Option<zwlr_layer_shell_v1::ZwlrLayerShellV1>,
    output_manager: Option<zxdg_output_manager_v1::ZxdgOutputManagerV1>,
    configured_count: usize,
    total_surfaces: usize,
}

impl AppState {
    fn new() -> Self {
        Self {
            outputs: HashMap::new(),
            compositor: None,
            layer_shell: None,
            output_manager: None,
            configured_count: 0,
            total_surfaces: 0,
        }
    }
}

struct FifoReader {
    fd: RawFd,
}

impl FifoReader {
    fn new(fifo_path: &str) -> Result<Self> {
        use std::os::unix::fs::OpenOptionsExt;
        let file = std::fs::OpenOptions::new()
            .read(true)
            .custom_flags(libc::O_NONBLOCK)
            .open(fifo_path)?;

        Ok(Self {
            fd: file.as_raw_fd(),
        })
    }

    fn read_sample(&mut self) -> Result<Option<StereoSample>> {
        let mut buffer = vec![0u8; N_SAMPLES * 4];

        let bytes_read = unsafe {
            libc::read(
                self.fd,
                buffer.as_mut_ptr() as *mut libc::c_void,
                buffer.len(),
            )
        };

        if bytes_read < 0 {
            let errno = unsafe { *libc::__errno_location() };
            if errno == libc::EAGAIN || errno == libc::EWOULDBLOCK {
                return Ok(None);
            }
            return Err(anyhow!("Failed to read from FIFO: {}", errno));
        }

        if bytes_read == 0 {
            return Ok(None);
        }

        let samples_read = bytes_read as usize / 4;
        let mut stereo = StereoSample::new();

        for i in 0..samples_read.min(N_SAMPLES / 2) {
            let base = i * 4;
            if base + 3 < buffer.len() {
                stereo.left[i] = i16::from_le_bytes([buffer[base], buffer[base + 1]]);
                stereo.right[i] = i16::from_le_bytes([buffer[base + 2], buffer[base + 3]]);
            }
        }

        Ok(Some(stereo))
    }
}

struct MediaRenderer {
    shader_program: u32,
    media_texture: Option<u32>,
    video_decoder: Option<VideoDecoder>,
    _vbo: u32,
    _ebo: u32,
    start_time: u64,
    media_type: MediaType,
}

impl MediaRenderer {
    fn new(media_type: MediaType) -> Result<Self> {
        eprintln!("Creating MediaRenderer with type: {:?}", media_type);

        let start_time = utils::get_time_millis();

        unsafe {
            gl::load_with(|s| {
                let c_str = CString::new(s).unwrap();
                let proc_addr = match CStr::from_bytes_with_nul(b"eglGetProcAddress\0") {
                    Ok(name) => libc::dlsym(libc::RTLD_DEFAULT, name.as_ptr()),
                    Err(_) => std::ptr::null_mut(),
                };
                if proc_addr.is_null() {
                    std::ptr::null()
                } else {
                    let get_proc_addr: extern "C" fn(*const i8) -> *const std::ffi::c_void =
                        std::mem::transmute(proc_addr);
                    get_proc_addr(c_str.as_ptr())
                }
            });

            gl::ClearColor(0.0, 0.0, 0.0, 1.0);
        }

        let (shader_program, media_texture, video_decoder) =
            if media_type == MediaType::Shader("default".to_string()) {
                let program = Self::default_shader()?;
                (program, None, None)
            } else {
                match &media_type {
                    MediaType::Shader(shader_path) => {
                        let program = Self::create_pure_shader(shader_path)?;
                        (program, None, None)
                    }
                    MediaType::Image { path, shader } => {
                        let texture = ImageLoader::load_texture(path)?;
                        let program = if let Some(shader_path) = shader {
                            Self::create_media_shader(shader_path)?
                        } else {
                            Self::create_default_shader()?
                        };
                        (program, Some(texture), None)
                    }
                    MediaType::Video { path, shader } => {
                        let decoder = VideoDecoder::new(path)?;
                        let texture = decoder.texture();
                        let program = if let Some(shader_path) = shader {
                            Self::create_media_shader(shader_path)?
                        } else {
                            Self::create_default_shader()?
                        };
                        (program, Some(texture), Some(decoder))
                    }
                }
            };

        let (vbo, ebo) = Self::setup_geometry()?;

        Ok(Self {
            shader_program,
            media_texture,
            video_decoder,
            _vbo: vbo,
            _ebo: ebo,
            start_time,
            media_type,
        })
    }

    fn default_shader() -> Result<u32> {
        let vert_source = r#"
            #version 100
            attribute highp vec2 datIn;
            attribute highp vec2 texIn;
            varying vec2 texCoords;
            void main() {
                texCoords = texIn;
                gl_Position = vec4(datIn, 0.0, 1.0);
            }
        "#;

        let frag_source = r#"
            #ifdef GL_ES
            precision mediump float;
            #endif
            void main() {
                gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
            }
        "#;

        Self::compile(vert_source, frag_source)
    }

    fn update_media(&mut self, new_media_type: MediaType) -> Result<()> {
        eprintln!("Updating media to: {:?}", new_media_type);

        if let Some(texture) = self.media_texture {
            unsafe {
                gl::DeleteTextures(1, &texture);
            }
        }
        self.video_decoder = None;

        let (shader_program, media_texture, video_decoder) = match &new_media_type {
            MediaType::Shader(shader_path) => {
                let program = Self::create_pure_shader(shader_path)?;
                (program, None, None)
            }
            MediaType::Image { path, shader } => {
                let texture = ImageLoader::load_texture(path)?;
                let program = if let Some(shader_path) = shader {
                    Self::create_media_shader(shader_path)?
                } else {
                    Self::create_default_shader()?
                };
                (program, Some(texture), None)
            }
            MediaType::Video { path, shader } => {
                let decoder = VideoDecoder::new(path)?;
                let texture = decoder.texture();
                let program = if let Some(shader_path) = shader {
                    Self::create_media_shader(shader_path)?
                } else {
                    Self::create_default_shader()?
                };
                (program, Some(texture), Some(decoder))
            }
        };

        unsafe {
            gl::DeleteProgram(self.shader_program);
        }

        self.shader_program = shader_program;
        self.media_texture = media_texture;
        self.video_decoder = video_decoder;
        self.media_type = new_media_type;

        Ok(())
    }

    fn create_pure_shader(shader_path: &str) -> Result<u32> {
        let raw = load_shader(shader_path)?;
        let mut version_directive: Option<&str> = None;
        let mut body_lines = Vec::new();
        for line in raw.lines() {
            let trimmed = line.trim_start();
            if version_directive.is_none() && trimmed.starts_with("#version") {
                version_directive = Some(line);
            } else {
                body_lines.push(line);
            }
        }
        body_lines.retain(|l| {
            let t = l.trim_start();
            !(t.starts_with("precision ") && t.ends_with("float;"))
        });
        let mut frag_source = String::new();
        if let Some(v) = version_directive {
            frag_source.push_str(v);
            frag_source.push('\n');
        }
        frag_source.push_str(
            r#"
            #ifdef GL_ES
              #ifdef GL_FRAGMENT_PRECISION_HIGH
                precision highp float;
              #else
                precision mediump float;
              #endif
            #endif
            "#,
        );
        frag_source.push_str(&body_lines.join("\n"));
        let vert_source = r#"
            #version 100
            attribute highp vec2 datIn;
            attribute highp vec2 texIn;
            varying vec2 texCoords;
            void main() {
                texCoords = texIn;
                gl_Position = vec4(datIn, 0.0, 1.0);
            }
        "#;
        Self::compile(vert_source, &frag_source)
    }

    fn create_media_shader(shader_path: &str) -> Result<u32> {
        let raw = load_shader(shader_path)?;
        let mut version_directive: Option<&str> = None;
        let mut body_lines = Vec::new();
        for line in raw.lines() {
            let trimmed = line.trim_start();
            if version_directive.is_none() && trimmed.starts_with("#version") {
                version_directive = Some(line);
            } else {
                body_lines.push(line);
            }
        }
        body_lines.retain(|l| {
            let t = l.trim_start();
            !(t.starts_with("precision ") && t.ends_with("float;"))
        });
        let mut frag_source = String::new();
        if let Some(v) = version_directive {
            frag_source.push_str(v);
            frag_source.push('\n');
        }
        frag_source.push_str(
            r#"
            #ifdef GL_ES
              #ifdef GL_FRAGMENT_PRECISION_HIGH
                precision highp float;
              #else
                precision mediump float;
              #endif
            #endif
            "#,
        );
        frag_source.push_str(&body_lines.join("\n"));
        let vert_source = vertex_shader();
        Self::compile(vert_source, &frag_source)
    }
    fn create_default_shader() -> Result<u32> {
        let vert_source = vertex_shader();
        let frag_source = default_shader();
        Self::compile(vert_source, frag_source)
    }

    fn compile(vert_source: &str, frag_source: &str) -> Result<u32> {
        unsafe {
            let program = gl::CreateProgram();

            let vert_shader = gl::CreateShader(gl::VERTEX_SHADER);
            let vert_c_str = CString::new(vert_source)?;
            gl::ShaderSource(vert_shader, 1, &vert_c_str.as_ptr(), std::ptr::null());
            gl::CompileShader(vert_shader);
            Self::check_compile(vert_shader, "vertex")?;

            let frag_shader = gl::CreateShader(gl::FRAGMENT_SHADER);
            let frag_c_str = CString::new(frag_source)?;
            gl::ShaderSource(frag_shader, 1, &frag_c_str.as_ptr(), std::ptr::null());
            gl::CompileShader(frag_shader);
            Self::check_compile(frag_shader, "fragment")?;

            gl::AttachShader(program, vert_shader);
            gl::AttachShader(program, frag_shader);
            gl::LinkProgram(program);
            Self::check_linked(program)?;

            gl::DeleteShader(vert_shader);
            gl::DeleteShader(frag_shader);

            Ok(program)
        }
    }

    fn check_compile(shader: u32, shader_type: &str) -> Result<()> {
        unsafe {
            let mut status = 0;
            gl::GetShaderiv(shader, gl::COMPILE_STATUS, &mut status);
            if status == gl::FALSE as i32 {
                let mut log_length = 0;
                gl::GetShaderiv(shader, gl::INFO_LOG_LENGTH, &mut log_length);
                let mut log = vec![0u8; log_length as usize];
                gl::GetShaderInfoLog(
                    shader,
                    log_length,
                    std::ptr::null_mut(),
                    log.as_mut_ptr() as *mut i8,
                );
                let log_str = CStr::from_ptr(log.as_ptr() as *const i8).to_string_lossy();
                return Err(anyhow!(
                    "{} shader compilation failed: {}",
                    shader_type,
                    log_str
                ));
            }
        }
        Ok(())
    }

    fn check_linked(program: u32) -> Result<()> {
        unsafe {
            let mut status = 0;
            gl::GetProgramiv(program, gl::LINK_STATUS, &mut status);
            if status == gl::FALSE as i32 {
                let mut log_length = 0;
                gl::GetProgramiv(program, gl::INFO_LOG_LENGTH, &mut log_length);
                let mut log = vec![0u8; log_length as usize];
                gl::GetProgramInfoLog(
                    program,
                    log_length,
                    std::ptr::null_mut(),
                    log.as_mut_ptr() as *mut i8,
                );
                let log_str = CStr::from_ptr(log.as_ptr() as *const i8).to_string_lossy();
                return Err(anyhow!("Program linking failed: {}", log_str));
            }
        }
        Ok(())
    }

    fn setup_geometry() -> Result<(u32, u32)> {
        let vertices: [f32; 16] = [
            -1.0, 1.0, 0.0, 1.0, -1.0, -1.0, 0.0, 0.0, 1.0, -1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0,
        ];

        let indices: [u32; 6] = [0, 1, 2, 2, 3, 0];

        unsafe {
            let mut vbo = 0;
            gl::GenBuffers(1, &mut vbo);
            gl::BindBuffer(gl::ARRAY_BUFFER, vbo);
            gl::BufferData(
                gl::ARRAY_BUFFER,
                (vertices.len() * std::mem::size_of::<f32>()) as isize,
                vertices.as_ptr() as *const _,
                gl::STATIC_DRAW,
            );

            let mut ebo = 0;
            gl::GenBuffers(1, &mut ebo);
            gl::BindBuffer(gl::ELEMENT_ARRAY_BUFFER, ebo);
            gl::BufferData(
                gl::ELEMENT_ARRAY_BUFFER,
                (indices.len() * std::mem::size_of::<u32>()) as isize,
                indices.as_ptr() as *const _,
                gl::STATIC_DRAW,
            );

            gl::VertexAttribPointer(
                0,
                2,
                gl::FLOAT,
                gl::FALSE,
                4 * std::mem::size_of::<f32>() as i32,
                std::ptr::null(),
            );
            gl::EnableVertexAttribArray(0);

            gl::VertexAttribPointer(
                1,
                2,
                gl::FLOAT,
                gl::FALSE,
                4 * std::mem::size_of::<f32>() as i32,
                (2 * std::mem::size_of::<f32>()) as *const _,
            );
            gl::EnableVertexAttribArray(1);

            Ok((vbo, ebo))
        }
    }

    fn draw(
        &mut self,
        fifo_reader: &mut Option<FifoReader>,
        output_width: i32,
        output_height: i32,
    ) -> Result<()> {
        unsafe {
            gl::UseProgram(self.shader_program);
            gl::Clear(gl::COLOR_BUFFER_BIT);
            gl::Viewport(0, 0, output_width, output_height);

            if let Some(ref mut decoder) = self.video_decoder {
                decoder.update_frame()?;
            }

            let time_loc =
                gl::GetUniformLocation(self.shader_program, b"time\0".as_ptr() as *const i8);
            if time_loc != -1 {
                let time = (utils::get_time_millis() - self.start_time) as f32 / 1000.0;
                gl::Uniform1f(time_loc, time);
            }

            let resolution_loc =
                gl::GetUniformLocation(self.shader_program, b"resolution\0".as_ptr() as *const i8);
            if resolution_loc != -1 {
                gl::Uniform2f(resolution_loc, output_width as f32, output_height as f32);
            }

            if let Some(texture) = self.media_texture {
                gl::ActiveTexture(gl::TEXTURE0);
                gl::BindTexture(gl::TEXTURE_2D, texture);

                let media_loc =
                    gl::GetUniformLocation(self.shader_program, b"u_media\0".as_ptr() as *const i8);
                if media_loc != -1 {
                    gl::Uniform1i(media_loc, 0);
                }
            }

            if let Some(reader) = fifo_reader {
                let fifo_loc =
                    gl::GetUniformLocation(self.shader_program, b"fifo\0".as_ptr() as *const i8);
                if fifo_loc != -1 {
                    if let Ok(Some(sample)) = reader.read_sample() {
                        let left_val = if !sample.left.is_empty() {
                            sample.left[0] as f32
                        } else {
                            0.0
                        };
                        let right_val = if !sample.right.is_empty() {
                            sample.right[0] as f32
                        } else {
                            0.0
                        };
                        gl::Uniform2f(fifo_loc, right_val, left_val);
                    }
                }
            }

            gl::DrawElements(gl::TRIANGLES, 6, gl::UNSIGNED_INT, std::ptr::null());
        }
        Ok(())
    }
}

struct MonitorState {
    egl_display: egl::Display,
    egl_surface: egl::Surface,
    egl_context: egl::Context,
    renderer: MediaRenderer,
    output_info: OutputInfo,
    _surface: wl_surface::WlSurface,
    _layer_surface: zwlr_layer_surface_v1::ZwlrLayerSurfaceV1,
    _egl_surface_wrapper: wayland_egl::WlEglSurface,
}

impl Dispatch<wl_registry::WlRegistry, ()> for AppState {
    fn event(
        state: &mut Self,
        registry: &wl_registry::WlRegistry,
        event: wl_registry::Event,
        _: &(),
        _: &Connection,
        qh: &QueueHandle<AppState>,
    ) {
        match event {
            wl_registry::Event::Global {
                name,
                interface,
                version,
            } => {
                debug!("Global: {} {} {}", name, interface, version);
                match interface.as_str() {
                    "wl_output" => {
                        let output =
                            registry.bind::<wl_output::WlOutput, _, _>(name, version, qh, name);
                        state.outputs.insert(
                            name,
                            OutputInfo {
                                _id: name,
                                output,
                                width: 0,
                                height: 0,
                                name: None,
                            },
                        );
                    }
                    "wl_compositor" => {
                        state.compositor =
                            Some(registry.bind::<wl_compositor::WlCompositor, _, _>(
                                name,
                                version,
                                qh,
                                (),
                            ));
                    }
                    "zwlr_layer_shell_v1" => {
                        state.layer_shell = Some(
                            registry.bind::<zwlr_layer_shell_v1::ZwlrLayerShellV1, _, _>(
                                name,
                                version,
                                qh,
                                (),
                            ),
                        );
                    }
                    "zxdg_output_manager_v1" => {
                        state.output_manager = Some(
                            registry.bind::<zxdg_output_manager_v1::ZxdgOutputManagerV1, _, _>(
                                name,
                                version,
                                qh,
                                (),
                            ),
                        );
                    }
                    _ => {}
                }
            }
            wl_registry::Event::GlobalRemove { name } => {
                state.outputs.remove(&name);
            }
            _ => {}
        }
    }
}

impl Dispatch<wl_output::WlOutput, u32> for AppState {
    fn event(
        state: &mut Self,
        _: &wl_output::WlOutput,
        event: wl_output::Event,
        output_id: &u32,
        _: &Connection,
        _: &QueueHandle<AppState>,
    ) {
        match event {
            wl_output::Event::Mode {
                flags,
                width,
                height,
                refresh: _,
            } => {
                if let Ok(mode_flags) = flags.into_result() {
                    if mode_flags.contains(wl_output::Mode::Current) {
                        if let Some(output_info) = state.outputs.get_mut(output_id) {
                            output_info.width = width;
                            output_info.height = height;
                        }
                    }
                }
            }
            _ => {}
        }
    }
}

impl Dispatch<zxdg_output_v1::ZxdgOutputV1, u32> for AppState {
    fn event(
        state: &mut Self,
        _: &zxdg_output_v1::ZxdgOutputV1,
        event: zxdg_output_v1::Event,
        output_id: &u32,
        _: &Connection,
        _: &QueueHandle<AppState>,
    ) {
        match event {
            zxdg_output_v1::Event::Name { name } => {
                if let Some(output_info) = state.outputs.get_mut(output_id) {
                    output_info.name = Some(name);
                }
            }
            _ => {}
        }
    }
}

impl Dispatch<zwlr_layer_surface_v1::ZwlrLayerSurfaceV1, ()> for AppState {
    fn event(
        state: &mut Self,
        surface: &zwlr_layer_surface_v1::ZwlrLayerSurfaceV1,
        event: zwlr_layer_surface_v1::Event,
        _: &(),
        _: &Connection,
        _: &QueueHandle<AppState>,
    ) {
        match event {
            zwlr_layer_surface_v1::Event::Configure {
                serial,
                width: _,
                height: _,
            } => {
                surface.ack_configure(serial);
                state.configured_count += 1;
            }
            _ => {}
        }
    }
}

impl Dispatch<wl_compositor::WlCompositor, ()> for AppState {
    fn event(
        _: &mut Self,
        _: &wl_compositor::WlCompositor,
        _: wl_compositor::Event,
        _: &(),
        _: &Connection,
        _: &QueueHandle<AppState>,
    ) {
    }
}

impl Dispatch<zwlr_layer_shell_v1::ZwlrLayerShellV1, ()> for AppState {
    fn event(
        _: &mut Self,
        _: &zwlr_layer_shell_v1::ZwlrLayerShellV1,
        _: zwlr_layer_shell_v1::Event,
        _: &(),
        _: &Connection,
        _: &QueueHandle<AppState>,
    ) {
    }
}

impl Dispatch<zxdg_output_manager_v1::ZxdgOutputManagerV1, ()> for AppState {
    fn event(
        _: &mut Self,
        _: &zxdg_output_manager_v1::ZxdgOutputManagerV1,
        _: zxdg_output_manager_v1::Event,
        _: &(),
        _: &Connection,
        _: &QueueHandle<AppState>,
    ) {
    }
}

impl Dispatch<wl_surface::WlSurface, ()> for AppState {
    fn event(
        _: &mut Self,
        _: &wl_surface::WlSurface,
        _: wl_surface::Event,
        _: &(),
        _: &Connection,
        _: &QueueHandle<AppState>,
    ) {
    }
}

impl Dispatch<wl_region::WlRegion, ()> for AppState {
    fn event(
        _: &mut Self,
        _: &wl_region::WlRegion,
        _: wl_region::Event,
        _: &(),
        _: &Connection,
        _: &QueueHandle<AppState>,
    ) {
    }
}

fn create_monitor_state(
    output_info: &OutputInfo,
    compositor: &wl_compositor::WlCompositor,
    layer_shell: &zwlr_layer_shell_v1::ZwlrLayerShellV1,
    layer_name: Option<&str>,
    media_type: MediaType,
    egl_instance: &egl::Instance<egl::Static>,
    conn: &Connection,
    qh: &QueueHandle<AppState>,
) -> Result<MonitorState> {
    let surface = compositor.create_surface(qh, ());

    let input_region = compositor.create_region(qh, ());
    let render_region = compositor.create_region(qh, ());
    render_region.add(0, 0, output_info.width, output_info.height);
    surface.set_opaque_region(Some(&render_region));
    surface.set_input_region(Some(&input_region));

    let layer = match layer_name {
        Some("top") => zwlr_layer_shell_v1::Layer::Top,
        Some("bottom") => zwlr_layer_shell_v1::Layer::Bottom,
        Some("overlay") => zwlr_layer_shell_v1::Layer::Overlay,
        Some("background") | None => zwlr_layer_shell_v1::Layer::Background,
        _ => zwlr_layer_shell_v1::Layer::Background,
    };

    let layer_surface = layer_shell.get_layer_surface(
        &surface,
        Some(&output_info.output),
        layer,
        "papyrust-daemon".to_string(),
        qh,
        (),
    );

    layer_surface.set_exclusive_zone(-1);
    layer_surface.set_size(output_info.width as u32, output_info.height as u32);
    surface.commit();

    let display_ptr = conn.display().id().as_ptr();
    let egl_display = unsafe { egl_instance.get_display(display_ptr as *mut _) }
        .ok_or_else(|| anyhow!("Failed to get EGL display for Wayland connection"))?;

    let _version = egl_instance.initialize(egl_display)?;

    let config_attribs = [
        egl::SURFACE_TYPE,
        egl::WINDOW_BIT,
        egl::RENDERABLE_TYPE,
        egl::OPENGL_ES2_BIT,
        egl::RED_SIZE,
        8,
        egl::GREEN_SIZE,
        8,
        egl::BLUE_SIZE,
        8,
        egl::NONE,
    ];

    let mut configs = Vec::with_capacity(1);
    egl_instance.choose_config(egl_display, &config_attribs, &mut configs)?;
    let config = configs
        .first()
        .ok_or_else(|| anyhow!("No suitable EGL config"))?;

    let context_attribs = [
        egl::CONTEXT_MAJOR_VERSION,
        2,
        egl::CONTEXT_MINOR_VERSION,
        0,
        egl::NONE,
    ];

    let context = egl_instance.create_context(egl_display, *config, None, &context_attribs)?;

    let egl_surface_wrapper =
        wayland_egl::WlEglSurface::new(surface.id(), output_info.width, output_info.height)?;

    let egl_surface = unsafe {
        egl_instance.create_window_surface(
            egl_display,
            *config,
            egl_surface_wrapper.ptr() as *mut _,
            Some(&[egl::NONE]),
        )?
    };

    egl_instance.make_current(
        egl_display,
        Some(egl_surface),
        Some(egl_surface),
        Some(context),
    )?;

    let renderer = MediaRenderer::new(media_type)?;

    Ok(MonitorState {
        egl_display,
        egl_surface,
        egl_context: context,
        renderer,
        output_info: output_info.clone(),
        _surface: surface,
        _layer_surface: layer_surface,
        _egl_surface_wrapper: egl_surface_wrapper,
    })
}

pub fn init(
    media_type: MediaType,
    fps: u16,
    layer_name: Option<&str>,
    _width: u16,
    _height: u16,
    fifo_path: Option<&str>,
    ipc_receiver: Receiver<MediaChange>,
) -> Result<()> {
    let conn = Connection::connect_to_env()?;
    let mut event_queue = conn.new_event_queue();
    let qh = event_queue.handle();

    let mut app_state = AppState::new();
    let _registry = conn.display().get_registry(&qh, ());

    event_queue.roundtrip(&mut app_state)?;

    if let Some(ref output_manager) = app_state.output_manager {
        for (id, output_info) in &app_state.outputs {
            let _xdg_output = output_manager.get_xdg_output(&output_info.output, &qh, *id);
        }
    }

    event_queue.roundtrip(&mut app_state)?;

    let compositor = app_state
        .compositor
        .as_ref()
        .ok_or_else(|| anyhow!("Compositor not available"))?;

    let layer_shell = app_state
        .layer_shell
        .as_ref()
        .ok_or_else(|| anyhow!("Layer shell not available"))?;

    let egl_instance = egl::Instance::new(egl::Static);
    let mut monitor_states = HashMap::new();

    for output_info in app_state.outputs.values() {
        if output_info.name.is_some() {
            match create_monitor_state(
                output_info,
                compositor,
                layer_shell,
                layer_name,
                media_type.clone(),
                &egl_instance,
                &conn,
                &qh,
            ) {
                Ok(monitor_state) => {
                    monitor_states
                        .insert(output_info.name.as_ref().unwrap().clone(), monitor_state);
                    app_state.total_surfaces += 1;
                }
                Err(e) => {
                    eprintln!(
                        "Failed to create monitor state for {}: {}",
                        output_info.name.as_ref().unwrap(),
                        e
                    );
                }
            }
        }
    }

    event_queue.roundtrip(&mut app_state)?;

    while app_state.configured_count < app_state.total_surfaces {
        event_queue.blocking_dispatch(&mut app_state)?;
    }

    event_queue.roundtrip(&mut app_state)?;

    if fps == 0 {
        for monitor_state in monitor_states.values() {
            egl_instance.swap_interval(monitor_state.egl_display, 1)?;
        }
    } else {
        for monitor_state in monitor_states.values() {
            egl_instance.swap_interval(monitor_state.egl_display, 0)?;
        }
    }

    let mut fifo_reader = if let Some(path) = fifo_path {
        Some(FifoReader::new(path)?)
    } else {
        None
    };

    info!(
        "Starting render loop with {} monitors",
        monitor_states.len()
    );

    loop {
        let frame_start = utils::get_time_millis();

        if let Ok(media_change) = ipc_receiver.try_recv() {
            if let Some(target_monitor) = &media_change.monitor {
                if let Some(monitor_state) = monitor_states.get_mut(target_monitor) {
                    egl_instance.make_current(
                        monitor_state.egl_display,
                        Some(monitor_state.egl_surface),
                        Some(monitor_state.egl_surface),
                        Some(monitor_state.egl_context),
                    )?;
                    if let Err(e) = monitor_state.renderer.update_media(media_change.media_type) {
                        eprintln!(
                            "Failed to update media for monitor {}: {}",
                            target_monitor, e
                        );
                    }
                } else {
                    eprintln!("Monitor {} not found", target_monitor);
                }
            } else {
                for monitor_state in monitor_states.values_mut() {
                    egl_instance.make_current(
                        monitor_state.egl_display,
                        Some(monitor_state.egl_surface),
                        Some(monitor_state.egl_surface),
                        Some(monitor_state.egl_context),
                    )?;
                    if let Err(e) = monitor_state
                        .renderer
                        .update_media(media_change.media_type.clone())
                    {
                        eprintln!(
                            "Failed to update media for monitor {}: {}",
                            monitor_state
                                .output_info
                                .name
                                .as_deref()
                                .unwrap_or("unknown"),
                            e
                        );
                    }
                }
            }
        }

        event_queue.dispatch_pending(&mut app_state)?;

        for monitor_state in monitor_states.values_mut() {
            egl_instance.make_current(
                monitor_state.egl_display,
                Some(monitor_state.egl_surface),
                Some(monitor_state.egl_surface),
                Some(monitor_state.egl_context),
            )?;

            monitor_state.renderer.draw(
                &mut fifo_reader,
                monitor_state.output_info.width,
                monitor_state.output_info.height,
            )?;

            egl_instance.swap_buffers(monitor_state.egl_display, monitor_state.egl_surface)?;
        }

        if fps > 0 {
            let frame_time = utils::get_time_millis() - frame_start;
            let target_frame_time = 1000 / fps as u64;
            if frame_time < target_frame_time {
                utils::sleep_millis(target_frame_time - frame_time);
            }
        }
    }
}
</file>

<file path="src/library/project.rs">
use serde::Deserialize;

#[derive(Deserialize, Debug, Clone, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum ProjectType {
    #[serde(alias = "Web")]
    Web,
    #[serde(alias = "Video")]
    Video,
    #[serde(alias = "Application")]
    Application,
    #[serde(alias = "Scene")]
    Scene,
}

#[derive(Deserialize, Debug, Clone)]
pub struct ProjectMeta {
    pub title: Option<String>,
    pub description: Option<String>,
    pub tags: Option<Vec<String>>,
    #[serde(rename = "type")]
    pub file_type: Option<ProjectType>,
    pub preview: Option<String>,
    pub file: Option<String>,
}

#[derive(Clone, Debug)]
pub struct Project {
    pub meta: ProjectMeta,
    pub path: String,
}
</file>

<file path="src/ui/mod.rs">
pub mod discover;
pub mod library;
pub mod panel;
pub mod popup;
pub mod state;
pub mod view;
</file>

<file path="src/library/loader.rs">
use std::{fs, path::PathBuf};

use super::project::{Project, ProjectMeta};

const WALLPAPER_ENGINE_ID: &str = "431960";
const WORKSHOP_PATHS: [&str; 4] = [
    "~/.steam/steam/steamapps/workshop",
    "~/.local/share/Steam/steamapps/workshop",
    "~/.var/app/com.valvesoftware.Steam/.local/share/Steam/steamapps/workshop",
    "~/snap/steam/common/.local/share/Steam/steamapps/workshop",
];

fn resolve_paths() -> Vec<PathBuf> {
    WORKSHOP_PATHS
        .iter()
        .map(|p| shellexpand::tilde(p).to_string())
        .map(PathBuf::from)
        .filter(|p| p.exists())
        .map(|p| p.join("content").join(WALLPAPER_ENGINE_ID))
        .filter(|p| p.exists())
        .collect()
}

pub struct Loader {
    project_paths: Vec<PathBuf>,
    current: usize,
}

impl Loader {
    pub fn new() -> Self {
        let mut paths = Vec::new();

        for base in resolve_paths() {
            if let Ok(entries) = fs::read_dir(base) {
                for entry in entries.flatten() {
                    let dir = entry.path();
                    if dir.is_dir() && dir.join("project.json").exists() {
                        paths.push(dir);
                    }
                }
            }
        }

        Loader {
            project_paths: paths,
            current: 0,
        }
    }

    pub fn next(&mut self) -> Option<Result<Project, String>> {
        if self.current >= self.project_paths.len() {
            None
        } else {
            let dir = self.project_paths[self.current].clone();
            self.current += 1;
            let path = dir.join("project.json");
            Some(parse(&path, &dir))
        }
    }
}

fn parse(path: &PathBuf, dir: &PathBuf) -> Result<Project, String> {
    let content = fs::read_to_string(path)
        .map_err(|e| format!("Failed to read {}: {}", path.display(), e))?;

    let meta: ProjectMeta = serde_json::from_str(&content)
        .map_err(|e| format!("JSON parse error in {}: {}", path.display(), e))?;

    Ok(Project {
        meta,
        path: dir.to_string_lossy().to_string(),
    })
}
</file>

<file path="src/ui/panel.rs">
use iced::{
    widget::{text, Button, Container, Row},
    Alignment, Element, Padding,
};

use crate::Message;

use super::state::Page;

pub fn build(_app: &crate::Papyrust) -> Element<Message> {
    let library = Button::new(text("Library"))
        .on_press(Message::SwitchPage(Page::Library))
        .padding(Padding::from([8, 16]));

    let discover = Button::new(text("Discover"))
        .on_press(Message::SwitchPage(Page::Discover))
        .padding(Padding::from([8, 16]));

    let content = Row::new()
        .push(library)
        .push(discover)
        .spacing(15)
        .align_y(Alignment::Center);

    Container::new(content)
        .padding(Padding::from([10, 20]))
        .into()
}
</file>

<file path=".gitignore">
/target
repomix-output.xml
flamegraph.svg
perf.data
perf.data.old
stacks.folded
</file>

<file path="src/ui/popup.rs">
use iced::{
    alignment::{Horizontal, Vertical},
    widget::{button, mouse_area, text, Button, Column, Container, Row, Space},
    Background, Border, Color, Element, Length, Padding, Shadow, Vector,
};
use iced_video_player::VideoPlayer;

use crate::{library::project::Project, Message, Papyrust};

pub fn build<'a>(app: &'a Papyrust, project: &'a Project) -> Element<'a, Message> {
    let title = project.meta.title.as_deref().unwrap_or("Untitled");

    let video_preview = create_preview(app, project);

    let close_button = Button::new(text("Close").size(16))
        .on_press(Message::ClosePopup)
        .padding(Padding::from([8, 12]))
        .style(|_theme, status| {
            let base = Color::from_rgba(0.2, 0.2, 0.2, 0.8);
            let hover = Color::from_rgba(0.3, 0.3, 0.3, 0.9);
            let border_color = Color::from_rgba(0.6, 0.6, 0.6, 0.5);

            button::Style {
                background: Some(Background::Color(
                    if matches!(status, iced::widget::button::Status::Hovered) {
                        hover
                    } else {
                        base
                    },
                )),
                border: Border {
                    radius: 8.0.into(),
                    width: 1.0,
                    color: border_color,
                },
                text_color: Color::WHITE,
                ..Default::default()
            }
        });

    let apply_button = Button::new(text("Apply").size(16))
        .padding(Padding::from([8, 12]))
        .style(|_theme, status| {
            let base = Color::from_rgba(0.2, 0.2, 0.2, 0.8);
            let hover = Color::from_rgba(0.3, 0.3, 0.3, 0.9);
            let border_color = Color::from_rgba(0.6, 0.6, 0.6, 0.5);

            button::Style {
                background: Some(Background::Color(
                    if matches!(status, iced::widget::button::Status::Hovered) {
                        hover
                    } else {
                        base
                    },
                )),
                border: Border {
                    radius: 8.0.into(),
                    width: 1.0,
                    color: border_color,
                },
                text_color: Color::WHITE,
                ..Default::default()
            }
        });

    let header = Row::new()
        .push(
            text(title)
                .size(24)
                .style(|_theme| iced::widget::text::Style {
                    color: Some(Color::WHITE),
                    ..Default::default()
                }),
        )
        .align_y(Vertical::Center);

    let footer_row = Row::new().spacing(10).push(close_button).push(apply_button);

    let footer = Container::new(footer_row)
        .align_x(Horizontal::Center)
        .width(Length::Fill);

    let popup_content = Column::new()
        .push(header)
        .push(video_preview)
        .push(Space::new(Length::Fill, Length::Fill))
        .push(footer)
        .spacing(20)
        .padding(20)
        .width(Length::Fill)
        .align_x(Horizontal::Center);

    let popup = Container::new(popup_content)
        .width(Length::Fixed(800.0))
        .height(Length::Fixed(600.0))
        .style(|_theme| iced::widget::container::Style {
            background: Some(Background::Color(Color::from_rgba(0.05, 0.05, 0.05, 0.98))),
            border: Border {
                radius: 16.0.into(),
                width: 2.0,
                color: Color::from_rgba(0.6, 0.6, 0.6, 0.4),
            },
            shadow: Shadow {
                color: Color::from_rgba(0.0, 0.0, 0.0, 0.5),
                offset: Vector::new(0.0, 8.0),
                blur_radius: 24.0,
            },
            ..Default::default()
        })
        .align_x(Horizontal::Center)
        .align_y(Vertical::Center);

    let protected = mouse_area(popup).on_press(Message::DoNothing);

    mouse_area(
        Container::new(protected)
            .width(Length::Fill)
            .height(Length::Fill)
            .style(|_theme| iced::widget::container::Style {
                background: Some(Background::Color(Color::from_rgba(0.0, 0.0, 0.0, 0.85))),
                ..Default::default()
            })
            .align_x(Horizontal::Center)
            .align_y(Vertical::Center),
    )
    .on_press(Message::ClosePopup)
    .into()
}

fn create_preview<'a>(app: &'a Papyrust, project: &'a Project) -> Element<'a, Message> {
    if let Some(file_name) = &project.meta.file {
        let video_path = format!("{}/{}", project.path, file_name);

        if let Some(video) = app.peek_video(&video_path) {
            let video_width = 720.0;
            let video_height = 405.0;

            Container::new(
                VideoPlayer::new(video)
                    .width(Length::Fixed(video_width))
                    .height(Length::Fixed(video_height)),
            )
            .width(Length::Fixed(video_width))
            .height(Length::Fixed(video_height))
            .style(|_theme| iced::widget::container::Style {
                background: Some(Background::Color(Color::from_rgba(0.0, 0.0, 0.0, 0.95))),
                border: Border {
                    radius: 12.0.into(),
                    width: 2.0,
                    color: Color::from_rgba(0.4, 0.4, 0.4, 0.5),
                },
                shadow: Shadow {
                    color: Color::from_rgba(0.0, 0.0, 0.0, 0.3),
                    offset: Vector::new(0.0, 4.0),
                    blur_radius: 12.0,
                },
                ..Default::default()
            })
            .align_x(Horizontal::Center)
            .align_y(Vertical::Center)
            .into()
        } else {
            let dots = match app.animation_state {
                0 => "Loading video.  ",
                1 => "Loading video.. ",
                2 => "Loading video...",
                _ => "Loading video   ",
            };

            let video_width = 720.0;
            let video_height = 405.0;

            Container::new(
                text(dots)
                    .size(18)
                    .style(|_theme| iced::widget::text::Style {
                        color: Some(Color::from_rgba(1.0, 1.0, 1.0, 0.8)),
                        ..Default::default()
                    }),
            )
            .width(Length::Fixed(video_width))
            .height(Length::Fixed(video_height))
            .style(|_theme| iced::widget::container::Style {
                background: Some(Background::Color(Color::from_rgba(0.15, 0.15, 0.15, 0.9))),
                border: Border {
                    radius: 12.0.into(),
                    width: 2.0,
                    color: Color::from_rgba(0.4, 0.4, 0.4, 0.5),
                },
                ..Default::default()
            })
            .align_x(Horizontal::Center)
            .align_y(Vertical::Center)
            .into()
        }
    } else {
        let video_width = 720.0;
        let video_height = 405.0;

        Container::new(text("No video available").size(18).style(|_theme| {
            iced::widget::text::Style {
                color: Some(Color::from_rgba(1.0, 1.0, 1.0, 0.8)),
                ..Default::default()
            }
        }))
        .width(Length::Fixed(video_width))
        .height(Length::Fixed(video_height))
        .style(|_theme| iced::widget::container::Style {
            background: Some(Background::Color(Color::from_rgba(0.15, 0.15, 0.15, 0.9))),
            border: Border {
                radius: 12.0.into(),
                width: 2.0,
                color: Color::from_rgba(0.4, 0.4, 0.4, 0.5),
            },
            ..Default::default()
        })
        .align_x(Horizontal::Center)
        .align_y(Vertical::Center)
        .into()
    }
}
</file>

<file path="src/ui/view.rs">
use iced::{
    alignment::{Horizontal, Vertical},
    widget::{image::Handle, Column, Container, Stack},
    Element, Length, Padding,
};
use iced_aw::Wrap;

use crate::{library::project::Project, Message, Papyrust};

use super::{discover, library, panel, popup, state};

pub fn build(app: &Papyrust) -> Element<Message> {
    let content = match app.current_page {
        state::Page::Discover => discover::build(app),
        state::Page::Library => library::build(app),
    };

    let main = Column::new()
        .push(content)
        .width(Length::Fill)
        .height(Length::Fill);

    let panel = Container::new(panel::build(app))
        .width(Length::Fill)
        .height(Length::Fill)
        .padding(Padding {
            top: 0.0,
            right: 20.0,
            bottom: 0.0,
            left: 0.0,
        })
        .align_x(Horizontal::Center)
        .align_y(Vertical::Bottom);

    let main_content = Column::new().push(main).push(
        Container::new(panel)
            .width(Length::Fill)
            .height(Length::Fixed(80.0)),
    );

    if let Some(ref project) = app.popup_state {
        Stack::new()
            .push(main_content)
            .push(popup::build(app, project))
            .into()
    } else {
        main_content.into()
    }
}

pub fn create_grid<'a>(
    app: &'a Papyrust,
    projects: &'a [Project],
    preview: &'a [Option<Handle>],
) -> Element<'a, Message> {
    let mut items = Vec::new();

    for (idx, project) in projects.iter().enumerate() {
        let handle = preview.get(idx).and_then(Clone::clone);
        items.push(library::render_item(app, project, handle));
    }

    Container::new(Wrap::with_elements(items).spacing(8.0).line_spacing(8.0))
        .width(Length::Fill)
        .padding(8)
        .into()
}
</file>

<file path="src/ui/state.rs">
use iced::{widget::image::Handle, Task};

use crate::{Message, Papyrust};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Page {
    Discover,
    Library,
}

impl Default for Page {
    fn default() -> Self {
        Page::Library
    }
}

pub fn update(app: &mut Papyrust, message: Message) -> Task<Message> {
    match message {
        Message::SwitchPage(page) => {
            app.current_page = page;
            if page == Page::Library {
                return app.library.next().unwrap_or_else(Task::none);
            }
            Task::none()
        }
        Message::PreviewDecoded(idx, w, h, pixels) => {
            let handle = Handle::from_rgba(w, h, pixels);
            app.library.preview[idx] = Some(handle);
            app.library.next().unwrap_or_else(Task::none)
        }
        Message::PreviewError(_idx) => app.library.next().unwrap_or_else(Task::none),
        Message::Tick => {
            app.tick();
            Task::none()
        }
        Message::OpenPopup(project) => {
            app.popup_state = Some(project.clone());

            if let Some(file_name) = &project.meta.file {
                let video_path = format!("{}/{}", project.path, file_name);
                if app.should_load(&video_path) {
                    return Papyrust::load_video_async(video_path);
                }
            }
            Task::none()
        }
        Message::ClosePopup => {
            for video in app.videos.values_mut() {
                video.set_paused(true);
            }
            app.popup_state = None;
            Task::none()
        }
        Message::LoadVideo(path) => {
            app.load_video(&path);
            Task::none()
        }
        Message::VideoLoaded(path) => {
            app.load_video(&path);
            Task::none()
        }
        Message::VideoError(path, error) => {
            eprintln!("Failed to load video {}: {}", path, error);
            Task::none()
        }
        Message::DoNothing => Task::none(),
    }
}
</file>

<file path="Cargo.toml">
[package]
name = "papyrust"
version = "0.1.0"
edition = "2024"

[dependencies]
derive = "1.0.0"
fast_image_resize = { version = "5.1.4", features = ["image"] }
futures = "0.3.31"
iced = { version = "0.13.1", features = ["advanced", "image", "tokio"] }
iced_aw = { version = "0.12.2", features = ["wrap"] }
iced_video_player = { git = "https://github.com/jazzfool/iced_video_player" }
image = "0.25.6"
serde = { version = "1.0.219", features = ["derive"] }
serde_json = "1.0.140"
shellexpand = "3.1.1"
tokio = { version = "1.45.1", features = ["fs"] }
url = "2.5.4"

clap = { version = "4.4", features = ["derive"] }
wayland-client = "0.31"
wayland-protocols = { version = "0.31", features = ["client", "unstable"] }
wayland-protocols-wlr = { version = "0.2", features = ["client"] }
wayland-egl = "0.32"
khronos-egl = { version = "6.0", features = ["static"] }
gl = "0.14"
libc = "0.2"
anyhow = "1.0"
thiserror = "1.0"
log = "0.4"
env_logger = "0.10"
ffmpeg-next = "7.1.0"

[build-dependencies]
gl_generator = "0.14"

[profile.release]
debug = true

[lints.rust]
unsafe_op_in_unsafe_fn = "allow"

[[bin]]
name = "papyrust-daemon"
path = "src/daemon/main.rs"

[[bin]]
name = "papyrust-cli"
path = "src/bin/cli.rs"

[[bin]]
name = "papyrust"
path = "src/main.rs"
</file>

<file path="src/ui/library.rs">
use iced::alignment::{Horizontal, Vertical};
use iced::widget::image::Handle;
use iced::widget::{Button, Column, Container};
use iced::{
    widget::{column, container, scrollable, text},
    Element, Length,
};
use iced::{Alignment, Padding, Task};
use image::{imageops, load_from_memory, RgbaImage};
use tokio::{fs, task};

use crate::library::{loader::Loader, project::Project};
use crate::{library, Message, Papyrust};

pub struct Library {
    pub projects: Vec<Project>,
    pub preview: Vec<Option<Handle>>,
}

const PREVIEW_WIDTH: f32 = 140.0;
const PREVIEW_HEIGHT: f32 = 140.0;

const ITEM_WIDTH: f32 = 160.0;
const ITEM_HEIGHT: f32 = 200.0;

impl Library {
    pub fn new() -> Self {
        let mut loader = Loader::new();
        let mut projects = Vec::new();
        let mut preview = Vec::new();

        while let Some(result) = loader.next() {
            match result {
                Ok(project) => {
                    // Skip for now all non-video projects
                    if project.meta.file_type != Some(library::project::ProjectType::Video) {
                        continue;
                    }
                    projects.push(project);
                    preview.push(None);
                }
                Err(e) => eprintln!("Project parse error: {}", e),
            }
        }

        Self { projects, preview }
    }

    pub fn next(&mut self) -> Option<Task<Message>> {
        self.projects
            .iter()
            .enumerate()
            .find(|(idx, proj)| self.preview[*idx].is_none() && proj.meta.preview.is_some())
            .map(|(idx, proj)| {
                let name = proj.meta.preview.as_ref().unwrap().clone();
                let path = format!("{}/{}", proj.path, name);
                Task::perform(
                    async move {
                        let buf = fs::read(&path).await.ok();
                        if let Some(bytes) = buf {
                            let decode = task::spawn_blocking(move || {
                                let img = load_from_memory(&bytes).ok()?;
                                let mut rgba = img.to_rgba8();

                                // Ik this is not the most efficient way to handle this, but iced forces me to do it this way
                                rgba = Self::resize_image(rgba, PREVIEW_WIDTH as u32);
                                rgba = Self::round_image(rgba, 4.0);
                                let (w, h) = rgba.dimensions();
                                Some((w, h, rgba.into_raw()))
                            })
                            .await
                            .ok()
                            .flatten();

                            if let Some((w, h, pixels)) = decode {
                                return (idx, Ok((w, h, pixels)));
                            }
                        }
                        (idx, Err(()))
                    },
                    |(i, result)| match result {
                        Ok((w, h, pixels)) => Message::PreviewDecoded(i, w, h, pixels),
                        Err(_) => Message::PreviewError(i),
                    },
                )
            })
    }

    fn round_image(img: RgbaImage, radius: f32) -> RgbaImage {
        let (width, height) = img.dimensions();
        let mut rounded = img.clone();

        let radius_u32 = radius as u32;
        let right_bound = width.saturating_sub(radius_u32);
        let bottom_bound = height.saturating_sub(radius_u32);
        let radius_sq = radius * radius;

        let corners = [
            (0..radius_u32, 0..radius_u32),
            (right_bound..width, 0..radius_u32),
            (0..radius_u32, bottom_bound..height),
            (right_bound..width, bottom_bound..height),
        ];

        for (x_range, y_range) in corners {
            for y in y_range {
                for x in x_range.clone() {
                    let (dx, dy) = match (x < radius_u32, y < radius_u32) {
                        (true, true) => (radius - x as f32, radius - y as f32),
                        (false, true) => {
                            (x as f32 - (width as f32 - radius - 1.0), radius - y as f32)
                        }
                        (true, false) => {
                            (radius - x as f32, y as f32 - (height as f32 - radius - 1.0))
                        }
                        (false, false) => (
                            x as f32 - (width as f32 - radius - 1.0),
                            y as f32 - (height as f32 - radius - 1.0),
                        ),
                    };

                    if dx * dx + dy * dy > radius_sq {
                        rounded.get_pixel_mut(x, y)[3] = 0;
                    }
                }
            }
        }

        rounded
    }
    fn resize_image(img: RgbaImage, target_size: u32) -> RgbaImage {
        let (width, height) = img.dimensions();

        let scale = target_size as f32 / width.max(height) as f32;
        let new_width = (width as f32 * scale) as u32;
        let new_height = (height as f32 * scale) as u32;

        let src_image = fast_image_resize::images::Image::from_vec_u8(
            width,
            height,
            img.into_raw(),
            fast_image_resize::PixelType::U8x4,
        )
        .unwrap();

        let mut dst_image = fast_image_resize::images::Image::new(
            new_width,
            new_height,
            fast_image_resize::PixelType::U8x4,
        );

        let mut resizer = fast_image_resize::Resizer::new();

        let resize_options = fast_image_resize::ResizeOptions::new().resize_alg(
            fast_image_resize::ResizeAlg::Convolution(fast_image_resize::FilterType::Lanczos3),
        );

        resizer
            .resize(&src_image, &mut dst_image, Some(&resize_options))
            .unwrap();

        let resized_rgba =
            RgbaImage::from_raw(new_width, new_height, dst_image.into_vec()).unwrap();

        let crop_x = (new_width.saturating_sub(target_size)) / 2;
        let crop_y = (new_height.saturating_sub(target_size)) / 2;

        imageops::crop_imm(&resized_rgba, crop_x, crop_y, target_size, target_size).to_image()
    }
}

pub fn build(app: &Papyrust) -> Element<Message> {
    let lib = &app.library;
    let grid = super::view::create_grid(&app, &lib.projects, &lib.preview);

    container(scrollable(column![text("Library").size(30), grid]))
        .padding(20)
        .width(Length::Fill)
        .height(Length::Fill)
        .into()
}

pub fn render_item<'a>(
    app: &Papyrust,
    project: &'a Project,
    preview: Option<Handle>,
) -> Element<'a, Message> {
    let title = project.meta.title.as_deref().unwrap_or("Untitled");
    let preview = create_preview(app, preview, project);

    Button::new(
        Container::new(
            Column::new()
                .align_x(Alignment::Center)
                .padding(Padding::new(0.0).top(4.0))
                .push(preview)
                .push(
                    text(title)
                        .size(14)
                        .style(|_theme: &_| iced::widget::text::Style {
                            color: Some(iced::Color::WHITE),
                            ..Default::default()
                        })
                        .width(Length::Fixed(ITEM_WIDTH - 20.0))
                        .align_x(Alignment::Center),
                )
                .spacing(8),
        )
        .width(Length::Fixed(ITEM_WIDTH))
        .height(Length::Fixed(ITEM_HEIGHT)),
    )
    .width(Length::Fixed(ITEM_WIDTH))
    .height(Length::Fixed(ITEM_HEIGHT))
    .style(|_theme, status| {
        let base_color = iced::Color::from_rgba(0.0, 0.0, 0.0, 0.15);
        let hover_color = iced::Color::from_rgba(0.5, 0.5, 0.5, 0.3);
        let border_color = iced::Color::from_rgba(0.0, 0.0, 0.0, 0.2);

        match status {
            iced::widget::button::Status::Hovered => iced::widget::button::Style {
                background: Some(iced::Background::Color(hover_color)),
                border: iced::Border {
                    radius: 8.0.into(),
                    width: 1.0,
                    color: border_color,
                },
                shadow: iced::Shadow {
                    color: iced::Color::from_rgba(0.0, 0.0, 0.0, 0.1),
                    offset: iced::Vector::new(0.0, 2.0),
                    blur_radius: 4.0,
                },
                ..Default::default()
            },
            _ => iced::widget::button::Style {
                background: Some(iced::Background::Color(base_color)),
                border: iced::Border {
                    radius: 8.0.into(),
                    ..Default::default()
                },
                ..Default::default()
            },
        }
    })
    .on_press(Message::OpenPopup(project.clone()))
    .into()
}

fn create_preview<'a>(
    app: &Papyrust,
    preview: Option<Handle>,
    project: &'a Project,
) -> Element<'a, Message> {
    if let Some(handle) = preview {
        Container::new(
            iced::widget::image(handle)
                .width(Length::Fixed(PREVIEW_WIDTH))
                .height(Length::Fixed(PREVIEW_HEIGHT)),
        )
        .width(Length::Fixed(PREVIEW_WIDTH))
        .height(Length::Fixed(PREVIEW_HEIGHT))
        .clip(true)
        .into()
    } else if project.meta.preview.is_some() {
        let dots = match app.animation_state {
            0 => "Loading.  ",
            1 => "Loading.. ",
            2 => "Loading...",
            _ => "Loading   ",
        };

        Container::new(text(dots).style(|_theme: &_| iced::widget::text::Style {
            color: Some(iced::Color::from_rgba(1.0, 1.0, 1.0, 0.6)),
            ..Default::default()
        }))
        .width(Length::Fixed(PREVIEW_WIDTH))
        .height(Length::Fixed(PREVIEW_HEIGHT))
        .align_x(Horizontal::Center)
        .align_y(Vertical::Center)
        .style(|_theme| iced::widget::container::Style {
            background: Some(iced::Background::Color(iced::Color::from_rgba(
                0.5, 0.5, 0.5, 0.1,
            ))),
            border: iced::Border {
                radius: 4.0.into(),
                ..Default::default()
            },
            ..Default::default()
        })
        .into()
    } else {
        Container::new(
            text("No preview").style(|_theme: &_| iced::widget::text::Style {
                color: Some(iced::Color::from_rgba(1.0, 1.0, 1.0, 0.6)),
                ..Default::default()
            }),
        )
        .width(Length::Fixed(PREVIEW_WIDTH))
        .height(Length::Fixed(PREVIEW_HEIGHT))
        .align_x(Horizontal::Center)
        .align_y(Vertical::Center)
        .style(|_theme| iced::widget::container::Style {
            background: Some(iced::Background::Color(iced::Color::from_rgba(
                0.5, 0.5, 0.5, 0.1,
            ))),
            border: iced::Border {
                radius: 4.0.into(),
                ..Default::default()
            },
            ..Default::default()
        })
        .into()
    }
}
</file>

<file path="src/main.rs">
use std::collections::HashMap;

use iced::{Element, Font, Settings, Subscription, Task};
use iced_video_player::Video;
use library::project::Project;
use ui::state;

mod library;
mod ui;

use ui::library::Library;
use ui::{state::Page, view};

pub struct Papyrust {
    pub current_page: Page,
    pub library: Library,
    pub animation_state: usize,
    pub popup_state: Option<Project>,
    pub videos: HashMap<String, Video>,
}

#[derive(Debug, Clone)]
pub enum Message {
    SwitchPage(Page),
    PreviewDecoded(usize, u32, u32, Vec<u8>),
    PreviewError(usize),
    OpenPopup(Project),
    ClosePopup,
    Tick,
    LoadVideo(String),
    VideoLoaded(String),
    VideoError(String, String),
    DoNothing,
}

const _FIRA_BYTES: &[u8] = include_bytes!("../fonts/FiraCodeNerdFontMono-Regular.ttf");
const _UNIFONT_BYTES: &[u8] = include_bytes!("../fonts/unifont.ttf");

const _FIRA: Font = Font::with_name("FiraCode Nerd Font Mono Reg");
const _UNIFONT: Font = Font::with_name("Unifont");

impl Papyrust {
    fn new() -> (Self, Task<Message>) {
        let mut library = Library::new();
        let first = library.next().unwrap_or_else(Task::none);
        (
            Papyrust {
                current_page: Page::default(),
                library,
                animation_state: 0,
                popup_state: None,
                videos: HashMap::new(),
            },
            first,
        )
    }

    pub fn load_video(&mut self, path: &str) -> Option<&Video> {
        if !self.videos.contains_key(path) {
            if let Ok(url) = url::Url::parse(&format!("file://{}", path)) {
                if let Ok(video) = Video::new(&url) {
                    self.videos.insert(path.to_string(), video);
                }
            }
        }
        self.videos.get(path)
    }

    pub fn load_video_async(path: String) -> Task<Message> {
        Task::perform(
            async move {
                match url::Url::parse(&format!("file://{}", path)) {
                    Ok(url) => match tokio::task::spawn_blocking(move || Video::new(&url)).await {
                        Ok(Ok(_)) => Message::VideoLoaded(path),
                        Ok(Err(e)) => Message::VideoError(path, e.to_string()),
                        Err(e) => Message::VideoError(path, format!("Task error: {}", e)),
                    },
                    Err(e) => Message::VideoError(path, format!("Invalid URL: {}", e)),
                }
            },
            |msg| msg,
        )
    }

    pub fn peek_video(&self, path: &str) -> Option<&Video> {
        self.videos.get(path)
    }

    pub fn should_load(&self, path: &str) -> bool {
        !self.videos.contains_key(path)
    }

    pub fn tick(&mut self) {
        self.animation_state = (self.animation_state + 1) % 4;
    }

    fn update(&mut self, message: Message) -> Task<Message> {
        state::update(self, message)
    }

    fn view(&self) -> Element<Message> {
        view::build(self)
    }

    fn subscription(&self) -> Subscription<Message> {
        iced::time::every(std::time::Duration::from_millis(300)).map(|_| Message::Tick)
    }
}

fn main() -> iced::Result {
    iced::application("Papyrust", Papyrust::update, Papyrust::view)
        // .font(FIRA_BYTES)
        // .font(UNIFONT_BYTES)
        // .default_font(FIRA)
        .settings(Settings {
            default_font: Font::MONOSPACE,
            ..Default::default()
        })
        .subscription(Papyrust::subscription)
        .theme(|_| iced::theme::Theme::GruvboxDark)
        .run_with(Papyrust::new)
}
</file>

</files>
