This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
src/
  library/
    loader.rs
    mod.rs
    project.rs
  ui/
    discover.rs
    library.rs
    mod.rs
    panel.rs
    state.rs
    view.rs
  main.rs
.gitignore
Cargo.toml
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/ui/discover.rs">
use iced::Element;

use crate::{Message, Papyrust};

pub fn build(_app: &Papyrust) -> Element<Message> {
    iced::widget::text("Discover").into()
}
</file>

<file path=".gitignore">
/target
</file>

<file path="src/library/loader.rs">
use std::{fs, path::PathBuf};

use super::project::{Project, ProjectMeta};

const WALLPAPER_ENGINE_ID: &str = "431960";

const WORKSHOP_PATHS: [&str; 4] = [
    "~/.steam/steam/steamapps/workshop",
    "~/.local/share/Steam/steamapps/workshop",
    "~/.var/app/com.valvesoftware.Steam/.local/share/Steam/steamapps/workshop",
    "~/snap/steam/common/.local/share/Steam/steamapps/workshop",
];

fn resolve_paths() -> Vec<PathBuf> {
    WORKSHOP_PATHS
        .iter()
        .map(|p| shellexpand::tilde(p).to_string())
        .map(PathBuf::from)
        .filter(|p| p.exists())
        .map(|p| p.join("content").join(WALLPAPER_ENGINE_ID))
        .filter(|p| p.exists())
        .collect()
}

pub fn discover_projects() -> Vec<Project> {
    let mut projects = Vec::new();

    for base_dir in resolve_paths() {
        if let Ok(entries) = fs::read_dir(base_dir) {
            for entry in entries.flatten() {
                let path = entry.path();
                if path.is_dir() {
                    let project_json = path.join("project.json");

                    if project_json.exists() {
                        match parse(&project_json, &path) {
                            // Pass the directory path
                            Ok(project) => projects.push(project),
                            Err(e) => eprintln!("Failed to parse project at {:?}: {}", path, e),
                        }
                    }
                }
            }
        }
    }

    projects
}

fn parse(json_path: &PathBuf, project_dir: &PathBuf) -> Result<Project, String> {
    let content = fs::read_to_string(json_path)
        .map_err(|e| format!("Failed to read file {}: {}", json_path.display(), e))?;

    let project_metadata: ProjectMeta = serde_json::from_str(&content)
        .map_err(|e| format!("Failed to parse JSON from {}: {}", json_path.display(), e))?;

    Ok(Project {
        meta: project_metadata,
        path: project_dir.to_string_lossy().to_string(),
    })
}
</file>

<file path="src/library/mod.rs">
pub mod loader;
pub mod project;
</file>

<file path="src/library/project.rs">
use serde::Deserialize;

#[derive(Deserialize, Debug, Clone)]
#[serde(rename_all = "lowercase")]
pub enum ProjectType {
    #[serde(alias = "Web")]
    Web,
    #[serde(alias = "Video")]
    Video,
    #[serde(alias = "Application")]
    Application,
    #[serde(alias = "Scene")]
    Scene,
}

#[derive(Deserialize, Debug, Clone)]
pub struct ProjectMeta {
    pub title: Option<String>,
    pub description: Option<String>,
    pub tags: Option<Vec<String>>,
    #[serde(rename = "type")]
    pub file_type: Option<ProjectType>,
    pub preview: Option<String>,
    pub file: Option<String>,
}

#[derive(Clone, Debug)]
pub struct Project {
    pub meta: ProjectMeta,
    pub path: String,
}
</file>

<file path="src/ui/mod.rs">
pub mod discover;
pub mod library;
pub mod panel;
pub mod state;
pub mod view;
</file>

<file path="src/ui/panel.rs">
use iced::{
    widget::{text, Button, Container, Row},
    Alignment, Element, Padding,
};

use crate::Message;

use super::state::Page;

pub fn build(_app: &crate::Papyrust) -> Element<Message> {
    let library = Button::new(text("Library"))
        .on_press(Message::SwitchPage(Page::Library))
        .padding(Padding::from([8, 16]));

    let discover = Button::new(text("Discover"))
        .on_press(Message::SwitchPage(Page::Discover))
        .padding(Padding::from([8, 16]));

    let content = Row::new()
        .push(library)
        .push(discover)
        .spacing(15)
        .align_y(Alignment::Center);

    Container::new(content)
        .padding(Padding::from([10, 20]))
        .into()
}
</file>

<file path="src/ui/view.rs">
use iced::{
    alignment::{Horizontal, Vertical},
    widget::{Column, Container},
    Element, Length, Padding,
};

use crate::{Message, Papyrust};

use super::{discover, library, panel, state};

pub fn build(app: &Papyrust) -> Element<Message> {
    let content = match app.current_page {
        state::Page::Discover => discover::build(app),
        state::Page::Library => library::build(app),
    };

    let main_content = Column::new()
        .push(content)
        .width(Length::Fill)
        .height(Length::Fill);

    let panel = Container::new(panel::build(app))
        .width(Length::Fill)
        .height(Length::Fill)
        .padding(Padding {
            top: 0.0,
            right: 20.0,
            bottom: 0.0,
            left: 0.0,
        })
        .align_x(Horizontal::Center)
        .align_y(Vertical::Bottom);

    Column::new()
        .push(main_content)
        .push(
            Container::new(panel)
                .width(Length::Fill)
                .height(Length::Fixed(80.0)),
        )
        .into()
}
</file>

<file path="src/ui/library.rs">
use iced::widget::image::Handle;
use iced::{
    alignment::{Horizontal, Vertical},
    widget::{column, container, image, scrollable, text, Column, Row},
    Element, Length,
};

use crate::{
    library::{loader::discover_projects, project::Project},
    Message, Papyrust,
};

pub struct Library {
    pub projects: Vec<Project>,
    pub preview_handles: Vec<Option<Handle>>,
}

impl Library {
    pub fn new() -> Self {
        let projects = discover_projects();
        let preview_handles = vec![None; projects.len()];
        Self {
            projects,
            preview_handles,
        }
    }
}

pub fn build(app: &Papyrust) -> Element<Message> {
    let lib = &app.library;
    let grid = create_grid(&lib.projects, &lib.preview_handles);

    container(scrollable(column!(text("Library").size(30), grid)))
        .padding(20)
        .width(Length::Fill)
        .height(Length::Fill)
        .into()
}

fn create_grid<'a>(
    projects: &'a [Project],
    preview_handles: &'a [Option<Handle>],
) -> Element<'a, Message> {
    const ITEMS_PER_ROW: usize = 3;
    let mut rows = Vec::new();
    let mut idx = 0;

    for chunk in projects.chunks(ITEMS_PER_ROW) {
        let mut cells = Vec::new();
        for project in chunk {
            let handle = preview_handles.get(idx).and_then(|h| h.clone());
            cells.push(render_item(project, handle));
            idx += 1;
        }
        // pad out last row
        while cells.len() < ITEMS_PER_ROW {
            cells.push(container(text("")).width(Length::FillPortion(1)).into());
        }
        rows.push(
            Row::with_children(cells)
                .spacing(15)
                .width(Length::Fill)
                .into(),
        );
    }

    Column::with_children(rows)
        .spacing(15)
        .width(Length::Fill)
        .into()
}

fn render_item<'a>(project: &'a Project, preview_handle: Option<Handle>) -> Element<'a, Message> {
    let title = project.meta.title.as_deref().unwrap_or("Untitled");
    let preview = create_preview(preview_handle, project);

    container(
        column![preview, text(title).size(16)]
            .spacing(5)
            .padding(10),
    )
    .width(Length::FillPortion(1))
    .height(Length::Fixed(150.0))
    .into()
}

fn create_preview<'a>(
    preview_handle: Option<Handle>,
    project: &'a Project,
) -> Element<'a, Message> {
    if let Some(handle) = preview_handle {
        image(handle)
            .width(Length::Fill)
            .height(Length::Fixed(100.0))
            .into()
    } else if project.meta.preview.is_some() {
        container(text("Loading..."))
            .width(Length::Fill)
            .height(Length::Fixed(100.0))
            .align_x(Horizontal::Center)
            .align_y(Vertical::Center)
            .into()
    } else {
        container(text("No preview"))
            .width(Length::Fill)
            .height(Length::Fixed(100.0))
            .align_x(Horizontal::Center)
            .align_y(Vertical::Center)
            .into()
    }
}
</file>

<file path="src/ui/state.rs">
use crate::{Message, Papyrust};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Page {
    Discover,
    Library,
}

impl Default for Page {
    fn default() -> Self {
        Page::Library
    }
}

pub fn update(app: &mut Papyrust, message: Message) {
    match message {
        Message::SwitchPage(page) => {
            app.current_page = page;
        }
        // Message::Error(err) => {
        // eprintln!("Error: {}", err);
        // }
        _ => {}
    }
}
</file>

<file path="Cargo.toml">
[package]
name = "papyrust"
version = "0.1.0"
edition = "2024"

[dependencies]
derive = "1.0.0"
iced = { version = "0.13.1", features = ["image"] }
iced_video_player = { git = "https://github.com/jazzfool/iced_video_player" }
serde = { version = "1.0.219", features = ["derive"] }
serde_json = "1.0.140"
shellexpand = "3.1.1"
tokio = "1.45.1"
url = "2.5.4"
</file>

<file path="src/main.rs">
use iced::widget::image::Handle;
use iced::{Element, Task};
use std::fs;

mod library;
mod ui;

use ui::{library::Library, state::Page, view};

pub struct Papyrust {
    pub current_page: Page,
    pub library: Library,
}

#[derive(Debug, Clone)]
pub enum Message {
    SwitchPage(Page),
    /// (project_index, optional_bytes)
    PreviewLoaded(usize, Option<Vec<u8>>),
}

impl Papyrust {
    fn new() -> (Self, Task<Message>) {
        let library = Library::new();

        // Spawn a Task for each preview file
        let tasks: Vec<_> = library
            .projects
            .iter()
            .enumerate()
            .filter_map(|(i, project)| {
                project.meta.preview.as_ref().map(|preview_name| {
                    let preview_path = format!("{}/{}", project.path, preview_name);
                    Task::perform(
                        async move {
                            let data = fs::read(preview_path).ok();
                            (i, data)
                        },
                        |(idx, data)| Message::PreviewLoaded(idx, data),
                    )
                })
            })
            .collect();

        (
            Papyrust {
                current_page: Page::default(),
                library,
            },
            Task::batch(tasks),
        )
    }

    fn update(&mut self, message: Message) -> Task<Message> {
        match message {
            Message::SwitchPage(page) => {
                self.current_page = page;
                Task::none()
            }
            Message::PreviewLoaded(index, maybe_bytes) => {
                if let Some(bytes) = maybe_bytes {
                    // Vec<u8> already implements Into<Bytes>, so just pass it directly:
                    let handle = Handle::from_bytes(bytes);
                    if index < self.library.preview_handles.len() {
                        self.library.preview_handles[index] = Some(handle);
                    }
                }
                Task::none()
            }
        }
    }

    fn view(&self) -> Element<Message> {
        view::build(self)
    }
}

fn main() -> iced::Result {
    iced::application("Papyrust", Papyrust::update, Papyrust::view)
        .theme(|_| iced::theme::Theme::GruvboxDark)
        .run_with(Papyrust::new)
}
</file>

</files>
