This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
src/
  library/
    loader.rs
    mod.rs
    project.rs
  ui/
    discover.rs
    library.rs
    mod.rs
    panel.rs
    state.rs
    view.rs
  main.rs
.gitignore
Cargo.toml
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/ui/discover.rs">
use iced::Element;

use crate::{Message, Papyrust};

pub fn build(_app: &Papyrust) -> Element<Message> {
    iced::widget::text("Discover").into()
}
</file>

<file path="src/library/mod.rs">
pub mod loader;
pub mod project;
</file>

<file path="src/library/project.rs">
use serde::Deserialize;

#[derive(Deserialize, Debug, Clone)]
#[serde(rename_all = "lowercase")]
pub enum ProjectType {
    #[serde(alias = "Web")]
    Web,
    #[serde(alias = "Video")]
    Video,
    #[serde(alias = "Application")]
    Application,
    #[serde(alias = "Scene")]
    Scene,
}

#[derive(Deserialize, Debug, Clone)]
pub struct ProjectMeta {
    pub title: Option<String>,
    pub description: Option<String>,
    pub tags: Option<Vec<String>>,
    #[serde(rename = "type")]
    pub file_type: Option<ProjectType>,
    pub preview: Option<String>,
    pub file: Option<String>,
}

#[derive(Clone, Debug)]
pub struct Project {
    pub meta: ProjectMeta,
    pub path: String,
}
</file>

<file path="src/ui/mod.rs">
pub mod discover;
pub mod library;
pub mod panel;
pub mod state;
pub mod view;
</file>

<file path="src/library/loader.rs">
use std::{fs, path::PathBuf};

use super::project::{Project, ProjectMeta};

const WALLPAPER_ENGINE_ID: &str = "431960";
const WORKSHOP_PATHS: [&str; 4] = [
    "~/.steam/steam/steamapps/workshop",
    "~/.local/share/Steam/steamapps/workshop",
    "~/.var/app/com.valvesoftware.Steam/.local/share/Steam/steamapps/workshop",
    "~/snap/steam/common/.local/share/Steam/steamapps/workshop",
];

fn resolve_paths() -> Vec<PathBuf> {
    WORKSHOP_PATHS
        .iter()
        .map(|p| shellexpand::tilde(p).to_string())
        .map(PathBuf::from)
        .filter(|p| p.exists())
        .map(|p| p.join("content").join(WALLPAPER_ENGINE_ID))
        .filter(|p| p.exists())
        .collect()
}

pub struct Loader {
    project_paths: Vec<PathBuf>,
    current: usize,
}

impl Loader {
    pub fn new() -> Self {
        let mut paths = Vec::new();

        for base in resolve_paths() {
            if let Ok(entries) = fs::read_dir(base) {
                for entry in entries.flatten() {
                    let dir = entry.path();
                    if dir.is_dir() && dir.join("project.json").exists() {
                        paths.push(dir);
                    }
                }
            }
        }

        Loader {
            project_paths: paths,
            current: 0,
        }
    }

    pub fn next(&mut self) -> Option<Result<Project, String>> {
        if self.current >= self.project_paths.len() {
            None
        } else {
            let dir = self.project_paths[self.current].clone();
            self.current += 1;
            let path = dir.join("project.json");
            Some(parse(&path, &dir))
        }
    }
}

fn parse(path: &PathBuf, dir: &PathBuf) -> Result<Project, String> {
    let content = fs::read_to_string(path)
        .map_err(|e| format!("Failed to read {}: {}", path.display(), e))?;

    let meta: ProjectMeta = serde_json::from_str(&content)
        .map_err(|e| format!("JSON parse error in {}: {}", path.display(), e))?;

    Ok(Project {
        meta,
        path: dir.to_string_lossy().to_string(),
    })
}
</file>

<file path="src/ui/panel.rs">
use iced::{
    widget::{text, Button, Container, Row},
    Alignment, Element, Padding,
};

use crate::Message;

use super::state::Page;

pub fn build(_app: &crate::Papyrust) -> Element<Message> {
    let library = Button::new(text("Library"))
        .on_press(Message::SwitchPage(Page::Library))
        .padding(Padding::from([8, 16]));

    let discover = Button::new(text("Discover"))
        .on_press(Message::SwitchPage(Page::Discover))
        .padding(Padding::from([8, 16]));

    let content = Row::new()
        .push(library)
        .push(discover)
        .spacing(15)
        .align_y(Alignment::Center);

    Container::new(content)
        .padding(Padding::from([10, 20]))
        .into()
}
</file>

<file path=".gitignore">
/target
repomix-output.xml
flamegraph.svg
perf.data
perf.data.old
stacks.folded
</file>

<file path="src/ui/view.rs">
use iced::widget::container;
use iced::{
    alignment::{Horizontal, Vertical},
    widget::{image, image::Handle, text, Column, Container, Row},
    Element, Length, Padding,
};

use crate::{library::project::Project, Message, Papyrust};

use super::{discover, library, panel, state};

pub fn build(app: &Papyrust) -> Element<Message> {
    let content = match app.current_page {
        state::Page::Discover => discover::build(app),
        state::Page::Library => library::build(app),
    };

    let main = Column::new()
        .push(content)
        .width(Length::Fill)
        .height(Length::Fill);

    let panel = Container::new(panel::build(app))
        .width(Length::Fill)
        .height(Length::Fill)
        .padding(Padding {
            top: 0.0,
            right: 20.0,
            bottom: 0.0,
            left: 0.0,
        })
        .align_x(Horizontal::Center)
        .align_y(Vertical::Bottom);

    Column::new()
        .push(main)
        .push(
            Container::new(panel)
                .width(Length::Fill)
                .height(Length::Fixed(80.0)),
        )
        .into()
}

pub fn create_grid<'a>(
    projects: &'a [Project],
    preview: &'a [Option<Handle>],
) -> Element<'a, Message> {
    const ITEMS_PER_ROW: usize = 3;
    let mut rows = Vec::new();
    let mut idx = 0;

    for chunk in projects.chunks(ITEMS_PER_ROW) {
        let mut cells = Vec::new();

        for project in chunk {
            let handle = preview.get(idx).and_then(Clone::clone);
            cells.push(render_item(project, handle));
            idx += 1;
        }

        while cells.len() < ITEMS_PER_ROW {
            cells.push(container(text("")).width(Length::FillPortion(1)).into());
        }

        rows.push(
            Row::with_children(cells)
                .spacing(15)
                .width(Length::Fill)
                .into(),
        );
    }

    Column::with_children(rows)
        .spacing(15)
        .width(Length::Fill)
        .into()
}

fn render_item<'a>(project: &'a Project, preview: Option<Handle>) -> Element<'a, Message> {
    let title = project.meta.title.as_deref().unwrap_or("Untitled");
    let preview = create_preview(preview, project);

    container(
        Column::new()
            .push(preview)
            .push(text(title).size(16))
            .spacing(5)
            .padding(10),
    )
    .width(Length::FillPortion(1))
    .height(Length::Fixed(150.0))
    .into()
}

fn create_preview<'a>(preview: Option<Handle>, project: &'a Project) -> Element<'a, Message> {
    if let Some(handle) = preview {
        image(handle)
            .width(Length::Fill)
            .height(Length::Fixed(100.0))
            .into()
    } else if project.meta.preview.is_some() {
        container(text("Loading..."))
            .width(Length::Fill)
            .height(Length::Fixed(100.0))
            .align_x(Horizontal::Center)
            .align_y(Vertical::Center)
            .into()
    } else {
        container(text("No preview"))
            .width(Length::Fill)
            .height(Length::Fixed(100.0))
            .align_x(Horizontal::Center)
            .align_y(Vertical::Center)
            .into()
    }
}
</file>

<file path="src/ui/state.rs">
use iced::Task;

use crate::{Message, Papyrust};

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Page {
    Discover,
    Library,
}

impl Default for Page {
    fn default() -> Self {
        Page::Library
    }
}

pub fn update(app: &mut Papyrust, message: Message) -> Task<Message> {
    match message {
        Message::SwitchPage(page) => {
            app.current_page = page;
            if page == Page::Library {
                return app.library.next().unwrap_or_else(Task::none);
            }
            Task::none()
        }
        Message::PreviewReady(index, handle_opt) => {
            if let Some(handle) = handle_opt {
                if index < app.library.preview.len() {
                    app.library.preview[index] = Some(handle);
                }
            }
            app.library.next().unwrap_or_else(Task::none)
        }
    }
}
</file>

<file path="Cargo.toml">
[package]
name = "papyrust"
version = "0.1.0"
edition = "2024"

[dependencies]
derive = "1.0.0"
futures = "0.3.31"
iced = { version = "0.13.1", features = ["image", "tokio"] }
iced_video_player = { git = "https://github.com/jazzfool/iced_video_player" }
serde = { version = "1.0.219", features = ["derive"] }
serde_json = "1.0.140"
shellexpand = "3.1.1"
tokio = { version = "1.45.1", features = ["fs", "macros", "rt", "rt-multi-thread"] }
url = "2.5.4"


[profile.release]
debug = true
</file>

<file path="src/ui/library.rs">
use iced::widget::image::Handle;
use iced::Task;
use iced::{
    widget::{column, container, scrollable, text},
    Element, Length,
};
use tokio::fs;

use crate::library::{loader::Loader, project::Project};
use crate::{Message, Papyrust};

pub struct Library {
    pub projects: Vec<Project>,
    pub preview: Vec<Option<Handle>>,
}

impl Library {
    pub fn new() -> Self {
        let mut loader = Loader::new();
        let mut projects = Vec::new();
        let mut preview = Vec::new();

        while let Some(result) = loader.next() {
            match result {
                Ok(project) => {
                    projects.push(project);
                    preview.push(None);
                }
                Err(e) => eprintln!("Project parse error: {}", e),
            }
        }

        Self { projects, preview }
    }

    pub fn next(&mut self) -> Option<Task<Message>> {
        self.projects
            .iter()
            .enumerate()
            .find(|(idx, proj)| self.preview[*idx].is_none() && proj.meta.preview.is_some())
            .map(|(idx, proj)| {
                let name = proj.meta.preview.as_ref().unwrap().clone();
                let path = format!("{}/{}", proj.path, name);
                Task::perform(
                    async move {
                        let data = tokio::fs::read(&path).await.ok();
                        (idx, data.map(Handle::from_bytes))
                    },
                    |(i, handle)| Message::PreviewReady(i, handle),
                )
            })
    }

    pub fn load_previews(&self) -> Vec<Task<Message>> {
        self.projects
            .iter()
            .enumerate()
            .filter_map(|(idx, proj)| {
                proj.meta.preview.as_ref().map(|name| {
                    let path = format!("{}/{}", proj.path, name);
                    Task::perform(
                        async move {
                            let data = fs::read(&path).await.ok();
                            (idx, data.map(Handle::from_bytes))
                        },
                        |(i, handle)| Message::PreviewReady(i, handle),
                    )
                })
            })
            .collect()
    }

    pub fn remaining(&self) -> bool {
        !self.projects.is_empty()
    }
}

pub fn build(app: &Papyrust) -> Element<Message> {
    let lib = &app.library;
    let grid = super::view::create_grid(&lib.projects, &lib.preview);

    container(scrollable(column![text("Library").size(30), grid]))
        .padding(20)
        .width(Length::Fill)
        .height(Length::Fill)
        .into()
}
</file>

<file path="src/main.rs">
use iced::widget::image::Handle;
use iced::{Element, Task};
use ui::state;

mod library;
mod ui;

use ui::library::Library;
use ui::{state::Page, view};

pub struct Papyrust {
    pub current_page: Page,
    pub library: Library,
}

#[derive(Debug, Clone)]
pub enum Message {
    SwitchPage(Page),
    PreviewReady(usize, Option<Handle>),
}

impl Papyrust {
    fn new() -> (Self, Task<Message>) {
        let mut library = Library::new();
        let first = library.next().unwrap_or_else(Task::none);
        (
            Papyrust {
                current_page: Page::default(),
                library,
            },
            // Task::batch(tasks),
            first,
        )
    }

    fn update(&mut self, message: Message) -> Task<Message> {
        state::update(self, message)
    }

    fn view(&self) -> Element<Message> {
        view::build(self)
    }
}

fn main() -> iced::Result {
    iced::application("Papyrust", Papyrust::update, Papyrust::view)
        .theme(|_| iced::theme::Theme::GruvboxDark)
        .run_with(Papyrust::new)
}
</file>

</files>
